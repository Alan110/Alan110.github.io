<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[nodejs生产环境运维]]></title>
      <url>http://http://localhost:4000/2017/10/15/nodejs-production-operation/</url>
      <content type="html"><![CDATA[<p>nodejs在生成环境的运维比较复杂，主要是版本多，切换成本较高，奈何node升级很快，node 包版本良莠不齐，稍不注意就使得我们的线上应用挂了。 node更新很快，跟进新的版本有助于程序的迭代，然而过于新也会导致线上的不稳定。</p>
<p><a href="https://github.com/nodejs/Release#release-schedule1" target="_blank" rel="external">nodejs官方发布计划</a></p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com/FhNgHi0m4FOSk2bwg0Y__99lRMKf" alt=""></p>
<p>每隔一年会发布一个LTS长期支持版本，生产环境都建议部署LTS版本。<br>可见今年10.31即将发布8.x的LTS版本，值得期待。这也是写本文的原因，准备升级server的node版本。</p>
<h2 id="node版本管理"><a href="#node版本管理" class="headerlink" title="node版本管理"></a>node版本管理</h2><blockquote>
<p><a href="https://github.com/tj/n" target="_blank" rel="external">n</a></p>
</blockquote>
<p>n是tj大神的项目,它是npm的一个包, 使用顺序是: node &gt; n &gt; node</p>
<p>它依赖一个已经安装好的node， 公用已经安装好的全局node，通过下载不同版本的node，进行替换。这会导致全局安装的node_module在不同版本的node中是<strong>共享的，虽然不用再次下载，但可能会存在兼容性问题</strong></p>
<p><code>npm install -g n</code><br><code>n 6.11.3</code><br><code>n ls</code></p>
<blockquote>
<p><a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm</a> (推荐)</p>
</blockquote>
<p>nvm 是一个bash脚本，独立与node 之外，<strong>安装多个node版本的备份保存在~/.nvm目录下，通过改变路径映射实现多版本切换</strong>。每个node版本都需要安装自己的全局模块。</p>
<p><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.5/install.sh | bash</code><br>安装nvm</p>
<p><code>command -v nvm</code><br>检测是否安装成功，在Linux上如果没有任何反应执行<code>source .zshrc/.bashrc</code> 或者重新打开一个shell</p>
<p><code>nvm install node</code><br>下载包，并自动切换到该版本，<strong>目前没有发现只下载，不自动切换的办法</strong></p>
<p><code>nvm install 6.11.3</code><br>安装具体版本</p>
<p><code>nvm ls</code><br>查看所有安装的版本<br><strong>如果在安装之前，已经有全局的node，在这里会看到一个system的版本，你可以再次使用它</strong><br><code>nvm use system</code><br><img src="http://o99eh3ii0.bkt.clouddn.com/FoXQxqmpBVQAMeV_VSt6Gd3v2AlS" alt=""></p>
<p><code>nvm run 6.11.2 file.js</code><br>使用指定版本运行js文件</p>
<p><code>nvm install 6 --reinstall-packages-from=5</code><br>每个版本都有自己的全局node_modules,好在它提供了一个参数，我们不用每次都重新手动安装。你可以指定从哪个版本复制包引用</p>
<h2 id="npm包版本管理"><a href="#npm包版本管理" class="headerlink" title="npm包版本管理"></a>npm包版本管理</h2><blockquote>
<p>npm</p>
</blockquote>
<p>npm 3 有个问题是当执行 npm install pkg –save-dev 的时候会自动写入package.json文件，但是其版本写的是<code>&quot;autoprefixer&quot;: &quot;^6.7.2&quot;</code> , <strong>我们知道^代表可以升级第二位开始的版本号，在别的地方install这个项目，可能版本号不一致，许多库第二位版本号升级也会有较大的改动，从而导致项目无法运行成功</strong>。</p>
<blockquote>
<p>yarn (推荐)</p>
</blockquote>
<p>yarn <strong>只是代替了npm的客户端，依旧是使用的npm的仓库</strong> 用法基本和npm 一致,yarn会生成yarn.lock 文件，确保依赖的版本 。 yarn add 一个包的某个版本， 会自动安装相关依赖</p>
<p><code>yarn config set registry https://registry.npm.taobao.org</code><br>使用淘宝镜像</p>
<p><code>yarn install</code><br><code>yarn add package</code><br><code>yarn remove package</code><br>常见命令</p>
<p><code>yarn upgrade vue</code><br>升级包，用这个命令，会自动安装相关依赖升级</p>
<blockquote>
<p>npm5</p>
</blockquote>
<p>npm5开始也有package.lock.json文件，也会锁定版本</p>
<h2 id="线上应用运维-pm2"><a href="#线上应用运维-pm2" class="headerlink" title="线上应用运维-pm2"></a><a href="http://pm2.keymetrics.io/docs/usage/signals-clean-restart/" target="_blank" rel="external">线上应用运维-pm2</a></h2><p>1.如果是ssh登录，运行node server，当断开ssh的时候，服务也会被断开<br>2.应用的输出日志</p>
<p>pm2这个完美解决这2个问题,应用挂了后会自动重启，还可以进行程序管理,可以监听文件变化自动重启，保存应用输出的所有日志。<br>所以可以不用单独做日志的处理，可以pm2可以捕获console，和程序运行异常的错误到.pm2/log。</p>
<p>常见命令<br><code>Pm2 start app.js</code><br><code>Pm2 restart app</code><br><code>Pm2 show app</code><br><code>Pm2 list</code><br><code>Pm2 logs app</code></p>
<blockquote>
<p>执行环境变化</p>
</blockquote>
<p>当执行命令变化时，比如添加的环境变量变化  ， NODE_ENV=production pm2 start app.js<br>需要执行 pm2 delete id ，删除应用，不然无论怎么restart，执行环境都没变</p>
<blockquote>
<p>不自动reload</p>
</blockquote>
<p>pm2 reload dpub2_pre –no-autorestart<br>所有的pm2 命令都要带上这个参数</p>
<blockquote>
<p>多线程</p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vue2-high-feature-render]]></title>
      <url>http://http://localhost:4000/2017/09/06/vue2-high-feature-render/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vue2高级技巧-组件复用]]></title>
      <url>http://http://localhost:4000/2017/09/06/vue2-high-fethure-reuse/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[restful api设计]]></title>
      <url>http://http://localhost:4000/2017/08/10/node-restfulapi/</url>
      <content type="html"><![CDATA[<p>前后端分离大行其道，往往是多个客户端，一个服务后端，后端变得服务化。接口越来越多，<strong>保证api的设计更符合人性化，简单，容易理解显得非常重要</strong></p>
<p>网站的本质是软件，互联网软件具有分布式的特点。<strong>对api的设计是属于软件架构的一部分。</strong></p>
<p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。</p>
<p>REST是<strong>互联网软件架构设计原则</strong>,它不是实体。具有rest特点的软件，我们称其为restful。</p>
<p>其实它所描述的是—“资源表现层状态转移”。 api其实也是资源的访问，和状态变换。那么对api抽象为标准成为可能。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>互联网软件，通过http实现资源的交流。我们上网其实就是访问各种资源。以及资源的”状态转移”。</p>
<h2 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h2><p>资源的表现形式, 如.png,.text,html, .css 等等。代表了各种各样的资源</p>
<h2 id="状态转化"><a href="#状态转化" class="headerlink" title="状态转化"></a>状态转化</h2><p>http是无状态的，资源的一切状态都存储在服务器上的。所以客户端需要通过某种手段告诉服务器进行状态转化</p>
<p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：<strong>GET、POST、PUT、DELETE</strong>。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>综上所述，restful架构具有以下特点:</p>
<ol>
<li>每一个URI代表一种资源</li>
<li>uri是名词，不能包含动词</li>
<li>客户端通过四个HTTP动词，对服务器端资源进行操作描述,如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET（SELECT）：从服务器取出资源（一项或多项）。</div><div class="line">POST（CREATE）：在服务器新建一个资源。</div><div class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</div><div class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</div><div class="line">DELETE（DELETE）：从服务器删除资源。</div></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET /zoos：列出所有动物园</div><div class="line">POST /zoos：新建一个动物园</div><div class="line">GET /zoos/ID：获取某个指定动物园的信息</div><div class="line">PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</div><div class="line">PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</div><div class="line">DELETE /zoos/ID：删除某个动物园</div><div class="line">GET /zoos/ID/animals：列出某个指定动物园的所有动物</div><div class="line">DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/05/restful_api.html</a><br><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[es6-模板字符串]]></title>
      <url>http://http://localhost:4000/2017/07/21/es6-template-string/</url>
      <content type="html"><![CDATA[<p>es6新增了模板字符串，增强了字符串变量的能力。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>模板字符串支持多行字符串，变量插值，以及函数标签。在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> str = <span class="string">`string text`</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> str = <span class="string">`string text line 1</span></div><div class="line">           string text line 2 `</div><div class="line"></div><div class="line"><span class="keyword">let</span> str = <span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> str = tag <span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></div></pre></td></tr></table></figure>
<p> 在${ } 内，支持任意的js表达式  </p>
<h2 id="标签函数"><a href="#标签函数" class="headerlink" title="标签函数"></a>标签函数</h2><p>标签函数可以理解为一个过滤器，filter 对模板字符串的输出做<strong>进一步过滤</strong>。<br><strong>返回值也不一定是一个字符串</strong>，可以是个函数或者别的类型</p>
<p>参数：</p>
<ul>
<li>strings [] 字符串的字面值数组，按照 ${} 符号分割，在下面的例子中，分别为 Hello 、world</li>
<li>$1 “”  对应每一个处理好的插值计算结果</li>
<li>$2  “”</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings, ...values</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(strings[<span class="number">0</span>]); <span class="comment">// "Hello "</span></div><div class="line">  <span class="built_in">console</span>.log(strings[<span class="number">1</span>]); <span class="comment">// " world "</span></div><div class="line">  <span class="built_in">console</span>.log(strings[<span class="number">2</span>]); <span class="comment">// ""</span></div><div class="line">  <span class="built_in">console</span>.log(values[<span class="number">0</span>]);  <span class="comment">// 15</span></div><div class="line">  <span class="built_in">console</span>.log(values[<span class="number">1</span>]);  <span class="comment">// 50</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">"Bazinga!"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> str = tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</div><div class="line"><span class="comment">// "Bazinga!"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>原始字符串</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings, ...values</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]); </div><div class="line">  <span class="comment">// "string text line 1 \\n string text line 2"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">tag<span class="string">`string text line 1 \n string text line 2`</span>;</div></pre></td></tr></table></figure>
<p>在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串。</p>
<h2 id="标签函数的应用"><a href="#标签函数的应用" class="headerlink" title="标签函数的应用"></a>标签函数的应用</h2><blockquote>
<p>过滤非法字符串</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeHTML</span>(<span class="params">strings, ...interpolatedValues</span>) </span>&#123; <span class="comment">// `...` essentially slices the arguments for us.</span></div><div class="line">  <span class="keyword">return</span> strings.reduce(<span class="function">(<span class="params">total, current, index</span>) =&gt;</span> &#123; <span class="comment">// use an arrow function for brevity here</span></div><div class="line">    total += current;</div><div class="line">    <span class="keyword">if</span> (interpolatedValues.hasOwnProperty(index)) &#123;</div><div class="line">      total += <span class="built_in">String</span>(interpolatedValues[index]).replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>).replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>).replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> total;</div><div class="line">  &#125;, <span class="string">''</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>过滤掉多行字符串中的空格</p>
</blockquote>
<p>fdsfsd</p>
<blockquote>
<p>简易模板引擎</p>
</blockquote>
<p>原理是利用标签函数可以拿到模板字符串中的所有字符串片段和变量值，并且一一对应,所以我们可以<strong>选择性的重新组装模板</strong>,或者对变量进行处理。这里借助了symbol变量，作为block片段的分隔符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> startBlockSentinel = <span class="built_in">Symbol</span>(<span class="string">'blockSentinel'</span>);</div><div class="line"><span class="keyword">var</span> ignoreBlockSentinel = <span class="built_in">Symbol</span>(<span class="string">'ignoreBlockSentinel'</span>);</div><div class="line"><span class="keyword">var</span> endBlockSentinel = <span class="built_in">Symbol</span>(<span class="string">'endBlockSentinel'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> helpers = &#123;</div><div class="line">    <span class="attr">if</span>: <span class="function">(<span class="params">condition, thenTemplate, elseTemplate = <span class="string">''</span></span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> condition ? startBlockSentinel : ignoreBlockSentinel;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">end</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> endBlockSentinel;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">unless</span>: <span class="function">(<span class="params">condition, thenTemplate, elseTemplate</span>) =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(!condition)</div><div class="line">        <span class="keyword">return</span> !condition ? startBlockSentinel : ignoreBlockSentinel;</div><div class="line">    &#125;,</div><div class="line">    registerHelper(name, fn) &#123;</div><div class="line">        helpers[name] = fn;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * 标签模板，修饰模板字符串的返回值</div><div class="line"> * 拼接字符串，变量和字面字符是一一对应的</div><div class="line"> * @param &#123;any&#125; strings  字面字符串数组</div><div class="line"> * @param &#123;any&#125; interpolatedValues  替换变量数组</div><div class="line"> * @returns </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">template</span>(<span class="params">strings, ...interpolatedValues</span>) </span>&#123;</div><div class="line">    <span class="comment">// 条件块状态记录</span></div><div class="line">    <span class="keyword">const</span> statusStuck = [];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> strings.reduce(<span class="function">(<span class="params">total, current, index</span>) =&gt;</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 拼接字符串, if为true, 或者不在if内</span></div><div class="line">        <span class="keyword">if</span> ((statusStuck.length &gt; <span class="number">0</span> &amp;&amp; statusStuck[statusStuck.length - <span class="number">1</span>] == startBlockSentinel) || statusStuck.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// +占位符之前的内容</span></div><div class="line">            total += current;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 更新当前状态</span></div><div class="line">        <span class="keyword">if</span> (interpolatedValues.hasOwnProperty(index)) &#123;</div><div class="line">            <span class="keyword">let</span> value = interpolatedValues[index];</div><div class="line">            <span class="keyword">if</span> (value === startBlockSentinel || value === ignoreBlockSentinel) &#123;</div><div class="line">                statusStuck.push(value);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value === endBlockSentinel) &#123;</div><div class="line">                statusStuck.pop();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// + 占位符变量，过滤非法字符,转义成了实体，不能有&lt;div&gt; </span></div><div class="line">                <span class="comment">// 只在是true block状态时才添加，否则丢弃</span></div><div class="line">                <span class="comment">// total +=  String(interpolatedValues[index]).replace(/&amp;/g, '&amp;amp;').replace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;');</span></div><div class="line">                <span class="keyword">if</span>(statusStuck[statusStuck.length - <span class="number">1</span>] == startBlockSentinel)&#123;</div><div class="line">                    total += <span class="built_in">String</span>(interpolatedValues[index]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> total;</div><div class="line"></div><div class="line">    &#125;, <span class="string">''</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; template, helpers &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[文件上传]]></title>
      <url>http://http://localhost:4000/2017/07/12/fileupload/</url>
      <content type="html"><![CDATA[<p>最近碰到了文件上传的需求，突然发现这个需求其实很常用，包括我的博客如何上传的图片等。我也希望自己写一个图床。</p>
<p>要做好文件上传，其实也并不容易</p>
<h2 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h2><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://baidu.com"</span> <span class="attr">target</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"uploadForm"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></div><div class="line">　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>/&gt;</span></div><div class="line">　　<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">id</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"upload"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>enctype 指明了表单数据在上传之前进行的编码方式</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>application/x-www-form-urlencoded</td>
<td style="text-align:left">在发送前urlencode编码所有字符（默认）, key,vlaue对</td>
</tr>
<tr>
<td>multipart/form-data</td>
<td style="text-align:left">不对字符编码。 在使用包含文件上传控件的表单时，必须使用该值。</td>
</tr>
<tr>
<td>text/plain</td>
<td style="text-align:left">空格转换为 “+” 加号，但不对特殊字符编码。</td>
</tr>
</tbody>
</table>
<ul>
<li><p>application/x-www-form-urlencoded<br>  使用get方式提交时，把表单数据(name1=value1&amp;name2=value2…)以键值对append到url后，用  ‘?’ 分割url和参数。使用post方式提交时，把表单数据以键值对放在请求体中传输。              </p>
</li>
<li><p>multipart/form-data<br>  表单数据被编码为一条消息，页上的每个input对应消息中的一个部分<br>  用boundary=—————————36243265420146”分割各个部分（boundary值由浏览器生成）。它不会对字符进行编码，一般用于传输二进制文件（图片、视频、、、）  </p>
</li>
</ul>
<blockquote>
<p>form表单的缺点</p>
</blockquote>
<ol>
<li>会刷新页面，跳转到action的地址</li>
<li>不够灵活，比如取消啊，,预览啊，或者别的验证，或者多文件上传之类的都不好做。</li>
</ol>
<h2 id="HTML5之FormData、FileReader"><a href="#HTML5之FormData、FileReader" class="headerlink" title="HTML5之FormData、FileReader"></a>HTML5之FormData、FileReader</h2><p>html5有个新的js对象，FormData可以用来模拟表单数据, 然后通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData#append" target="_blank" rel="external">ajax上传文件</a>.</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData#append" target="_blank" rel="external">FormData API</a></li>
<li>FormData 对象可以通过form，dom元素构造，也可以通过new FormData(), 然后append键值对</li>
<li>FormData 对象的字段类型可以是 Blob, File, 或者 string: 如果它的字段类型不是Blob也不是File，则会被转换成字符串类型。</li>
<li>FormData 的字段属性不能<strong>直接删除</strong>，需要调用FormData.delete,不过目前兼容性不好</li>
</ul>
<p>下面是一个通过表单，利用ajax上传的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">name</span>=<span class="string">"fileinfo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Your email address:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">autocomplete</span>=<span class="string">"on"</span> <span class="attr">autofocus</span> <span class="attr">name</span>=<span class="string">"userid"</span> <span class="attr">placeholder</span>=<span class="string">"email"</span> <span class="attr">required</span> <span class="attr">size</span>=<span class="string">"32"</span> <span class="attr">maxlength</span>=<span class="string">"64"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Custom file label:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"filelabel"</span> <span class="attr">size</span>=<span class="string">"12"</span> <span class="attr">maxlength</span>=<span class="string">"32"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>File to stash:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">required</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Stash the file!"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.forms.namedItem(<span class="string">"fileinfo"</span>);</div><div class="line">form.addEventListener(<span class="string">'submit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> oOutput = <span class="built_in">document</span>.querySelector(<span class="string">"div"</span>),</div><div class="line">      oData = <span class="keyword">new</span> FormData(form);</div><div class="line"></div><div class="line">  oData.append(<span class="string">"CustomField"</span>, <span class="string">"This is some extra data"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> oReq = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  oReq.open(<span class="string">"POST"</span>, <span class="string">"stash.php"</span>, <span class="literal">true</span>);</div><div class="line">  oReq.onload = <span class="function"><span class="keyword">function</span>(<span class="params">oEvent</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (oReq.status == <span class="number">200</span>) &#123;</div><div class="line">      oOutput.innerHTML = <span class="string">"Uploaded!"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      oOutput.innerHTML = <span class="string">"Error "</span> + oReq.status + <span class="string">" occurred when trying to upload your file.&lt;br \/&gt;"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  oReq.send(oData);</div><div class="line">  ev.preventDefault();</div><div class="line">&#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>也可以不经过表单，通过input 的onchange事件拿到要上传的文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"webupload"</span> <span class="attr">style</span>=<span class="string">"width:170px;"</span>  <span class="attr">accept</span>=<span class="string">"image/png"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> input = doucument.querySelector(<span class="string">'#webupload'</span>);</div><div class="line">input.onchange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> file e.target.files[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="comment">// 准备formData</span></div><div class="line">    <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</div><div class="line">    formData.append(<span class="string">'file'</span>, file);</div><div class="line"></div><div class="line">    <span class="comment">// 开始上传</span></div><div class="line">    $.ajax(&#123;</div><div class="line">        <span class="attr">url</span>: <span class="keyword">this</span>.server,</div><div class="line">        <span class="attr">type</span>: <span class="string">'POST'</span>,</div><div class="line">        <span class="attr">data</span>: formData,</div><div class="line">        <span class="attr">processData</span>: <span class="literal">false</span>, <span class="comment">// 不处理发送的数据，因为data值是Formdata对象，不需要对数据做处理</span></div><div class="line">        cache: <span class="literal">false</span>,</div><div class="line">        <span class="attr">dataType</span>: <span class="string">'json'</span>,</div><div class="line">        <span class="attr">contentType</span>: <span class="literal">false</span>, </div><div class="line">        <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意如果用jquery，<strong>processData要为false</strong>，不做编码处理</p>
<p>当二次上传的时候，input还保留了以前的value，如果选择到了同一个文件，<strong>则不会触发onchange事件</strong>，所以，在上传完毕后要清空input的value</p>
<p>我测试直接设置input.value = ‘’ , 是不成功的。<br>另一个方案是，<strong>使用form元素的reset(),方法</strong>，会清空form里面所有input的值</p>
</blockquote>
<p><strong>FormData的兼容性</strong></p>
<p>现代浏览器Android4.4以上都支持，IE10及其以上支持<br><img src="http://o99eh3ii0.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170712084359.png" alt=""></p>
<h2 id="FormData-上传base64图片"><a href="#FormData-上传base64图片" class="headerlink" title="FormData 上传base64图片"></a>FormData 上传base64图片</h2><p>FormData支持blob对象，所以把base64转成blob对象即可, 以下是一个转换算法示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> base64ToBlob =  <span class="function"><span class="keyword">function</span> (<span class="params">base64, mime</span>) </span>&#123;</div><div class="line">        mime = mime || <span class="string">''</span>;</div><div class="line">        <span class="keyword">var</span> sliceSize = <span class="number">1024</span>;</div><div class="line">        <span class="keyword">var</span> byteChars = <span class="built_in">window</span>.atob(base64);</div><div class="line">        <span class="keyword">var</span> byteArrays = [];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> offset = <span class="number">0</span>, len = byteChars.length; offset &lt; len; offset += sliceSize) &#123;</div><div class="line">            <span class="keyword">var</span> slice = byteChars.slice(offset, offset + sliceSize);</div><div class="line"></div><div class="line">            <span class="keyword">var</span> byteNumbers = <span class="keyword">new</span> <span class="built_in">Array</span>(slice.length);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; slice.length; i++) &#123;</div><div class="line">                byteNumbers[i] = slice.charCodeAt(i);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">var</span> byteArray = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(byteNumbers);</div><div class="line"></div><div class="line">            byteArrays.push(byteArray);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Blob(byteArrays, &#123; <span class="attr">type</span>: mime &#125;);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">var</span> base64ImageContent = base64String.replace(<span class="regexp">/^data:image\/(png|jpg|jpeg);base64,/</span>, <span class="string">""</span>);</div><div class="line">    <span class="keyword">var</span> blob = utils.base64ToBlob(base64ImageContent, <span class="string">'image/png'</span>);</div><div class="line">    <span class="keyword">var</span> fileOfBlob = <span class="keyword">new</span> File([blob], <span class="string">'img'</span>+ <span class="built_in">Math</span>.random() +<span class="string">'.jpg'</span>); <span class="comment">// 指定文件名</span></div><div class="line">    <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</div><div class="line">    formData.append(<span class="string">'file'</span>, fileOfBlob);</div></pre></td></tr></table></figure>
<blockquote>
<p>这里转成blob对象后并没有直接放入FormData,而是又转成了file对象，目的是为了指定文件本身的文件名，当然如果对文件名没有要求的，可以忽略这一步。大部分后端会依赖文件名以及后缀，做一些处理。</p>
</blockquote>
<h2 id="分片上传超大文件"><a href="#分片上传超大文件" class="headerlink" title="分片上传超大文件"></a>分片上传超大文件</h2><p>上传文件过大会有很多问题，往往server只支持2MB大小的数据。此时可以利用分片上传超大文件</p>
<p>原理是利用<strong>file对象的slice</strong>方法，切割文件，发送多个请求，然后后端拼接文件。</p>
<ul>
<li>需要知道总共的分片数，</li>
<li>当前的分片数据</li>
<li>每片的字节大小</li>
<li>当前的分片index</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">    * 分片上传</div><div class="line">    * 递归上传切割出来的分片</div><div class="line">    * 注意上传的额外formData，告诉server如何合并文件</div><div class="line">    */</div><div class="line">chunkUploadFile(file) &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> chunkUpload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line"></div><div class="line">        curChunkIndex += <span class="number">1</span>;</div><div class="line">        <span class="keyword">let</span> start = curChunkIndex * <span class="keyword">this</span>.chunkSize;  <span class="comment">// 切割数据</span></div><div class="line">        <span class="keyword">let</span> end = <span class="built_in">Math</span>.min(file.size, start + <span class="keyword">this</span>.chunkSize);</div><div class="line"></div><div class="line">        <span class="comment">// 准备formData</span></div><div class="line">        <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</div><div class="line">        <span class="keyword">let</span> chunkFile = file.slice(start, end);</div><div class="line">        chunkFile = <span class="keyword">new</span> File([chunkFile], file.name);</div><div class="line">        chunkFile.filename = file.name;</div><div class="line">        formData.append(<span class="string">'file'</span>, chunkFile);</div><div class="line">        formData.append(<span class="string">'size'</span>, chunkFile.size);</div><div class="line">        formData.append(<span class="string">'lastModifiedDate'</span>, file.lastModifiedDate);</div><div class="line">        formData.append(<span class="string">'name'</span>, file.name);</div><div class="line">        formData.append(<span class="string">'chunks'</span>, chunkCount);</div><div class="line">        formData.append(<span class="string">'type'</span>, file.type);</div><div class="line">        formData.append(<span class="string">'chunk'</span>, curChunkIndex);</div><div class="line">        formData.append(<span class="string">'id'</span>, <span class="string">'WU_FILE_0'</span>);  <span class="comment">// 这个名字是固定，估计是server用来合并文件</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> <span class="keyword">this</span>.formData) &#123;</div><div class="line">            formData.append(prop, <span class="keyword">this</span>.formData[prop]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 开始上传</span></div><div class="line">        $.ajax(&#123;</div><div class="line">            <span class="attr">url</span>: <span class="keyword">this</span>.server,</div><div class="line">            <span class="attr">type</span>: <span class="string">'POST'</span>,</div><div class="line">            <span class="attr">data</span>: formData,</div><div class="line">            <span class="attr">processData</span>: <span class="literal">false</span>, <span class="comment">// 不处理发送的数据，因为data值是Formdata对象，不需要对数据做处理</span></div><div class="line">            cache: <span class="literal">false</span>,</div><div class="line">            <span class="attr">dataType</span>: <span class="string">'json'</span>,</div><div class="line">            <span class="attr">contentType</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">                self.$emit(<span class="string">'error'</span>, e);</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">                <span class="keyword">if</span> (curChunkIndex + <span class="number">1</span> &lt; chunkCount) &#123;</div><div class="line">                    chunkUpload();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    self.$emit(<span class="string">'success'</span>, res);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 上传之前</span></div><div class="line">    <span class="keyword">this</span>.$emit(<span class="string">'beforeUpload'</span>, file);</div><div class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">let</span> chunkCount = <span class="built_in">Math</span>.ceil(file.size / <span class="keyword">this</span>.chunkSize);</div><div class="line">    <span class="keyword">let</span> curChunkIndex = <span class="number">-1</span>;</div><div class="line"></div><div class="line">    chunkUpload();</div><div class="line"></div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h2 id="flash"><a href="#flash" class="headerlink" title="flash"></a>flash</h2><p>flash 虽然可以实现以上的所有能力，但它终将死亡，这里就不再叙述了。能用到flash的一般都是为了兼容老的浏览器。<br>希望web生态越来好，紧跟标准。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实文件上传，FormData是属于xhr的level2的新特性之一，可以关注一下底层规范。<br>原生js的能力已经越来越强大了，很多新能力已经能在实际生产中使用了，我们要学道，而不是术，底层原理是基础,关注规范。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[同步你的window和mac工作环境]]></title>
      <url>http://http://localhost:4000/2017/07/01/window-mac-working-sync/</url>
      <content type="html"><![CDATA[<p>我公司的电脑是mac，家里的电脑是windows，有时候不想带电脑回家，或者不想放着家里台式机强悍的性能浪费。还有我那快生灰的信仰键盘，hhkb。。。 所以我幻想着有一天能够什么都不带，<strong>在任何平台</strong>都可以开始我的工作。。</p>
<p>然而现实总是很残酷的。除了文件同步这个关键功能外，还有各个平台的差异性，如何统一，也是非常麻烦的。比如按键，比如开发工具，比如平台的生态环境等等。<br>所以我的需求总结起来也就是如下：</p>
<ol>
<li>文件同步</li>
<li>开发工具统一</li>
<li>按键统一</li>
</ol>
<h2 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a>文件同步</h2><p>其实比较好的方式，是用<strong>云同步盘</strong>，自动同步window和mac端的文件，可惜金山快盘倒了以后就没有比较好的跨平台同步盘了。 别的软件，比如百度同步盘，坚果等，在不同平台表现差异比较大，还出现过文件丢失的情况。</p>
<p>无奈之下只好使用git了,我们需要同步的东西，大多数是项目工程，或者配置文件等等。所以拆分成git项目，其实也是有助于我们的管理的。避免出现同步很大，很杂的东西，毕竟不是网盘。</p>
<p>放在git上，也有个问题，那就是安全性了。有些东西不好放在外面，隐私性要求高，同时能也不喜欢GitHub的高额收费。。。所以这里我选择了gitlab，<strong>可以无限制的创建私有项目</strong>，体验也与github差不多，如果哪一天想开源了，就转到GitHub上就行。</p>
<p>所以每天开发完毕要记得同步git。</p>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>我认为开发工具应该有2个，一个是小巧的文本编辑器，一个是强大的ide, 各司其职。<br>我选择了<strong>vscode和webstorm</strong>，这2个工具都是跨平台的，对前端开发很友好。</p>
<blockquote>
<p>配置同步</p>
</blockquote>
<p> webstorm依然可以借助git，导出setting.jar<br> vscode可以使用sync的插件，利用GitHub的gist，它其实本质上是一个简化的git仓库。<br> 要注意的是这个功能需要2个秘钥，一个是GitHub生产的，用于上传，一个是gist生产的，用于下载, <strong>这2个秘钥都要记得保存，它只能看1次</strong>。<br> sync这个插件还有一个能力，是区分平台配置，比如在mac和windows上的按键配置会自动区分，并保存，linux上会不会再区分一个，这个没试过。 详情使用可以看sync的插件说明</p>
<blockquote>
<p>shell</p>
</blockquote>
<p> 还有一项必不可少的工具就是shell了。<br> 开发者当然是离不开shell的了，如果你能，那当我没说。。。。<br> mac上的终端工具很多，windows就比较麻烦了, 自带的cmd惨不忍睹，powershell也不支持bash的命令。<strong>解决方案是安装git bash</strong>，选择<strong>嵌入比较深</strong>的那个解决方案，这样在cmd，和powershell里面也可以使用一些常用的shell命令了。</p>
<p> 好在vscode和webstorm都支持内嵌终端模拟器，可以选择自定义shell, 在windows上推荐用powershell，比cmd和git bash 自带的模拟环境干净不少。</p>
<blockquote>
<p>cros-env</p>
</blockquote>
<p>还有个问题是，在windows上不支持带环境变量的shell命令，比如   NODE_ENV=dev npm run dev , 会认为是非法命令。<br>解决方法是安装一个叫cors-env的一个npm包，在执行的命令前面加上cros就行了。</p>
<h2 id="按键统一"><a href="#按键统一" class="headerlink" title="按键统一"></a>按键统一</h2><p>习惯了mac的按键，windows的按键极不顺手，特别是对于键盘党来说。 这里使用autokey这个软件，在windows上模拟mac的按键。 献上<a href="https://autohotkey.com/docs/Tutorial.htm" target="_blank" rel="external">官方文档</a></p>
<p>autokey这个软件挺强的，也不需要重新启动，只要运行脚本就好了，不想用了或者想换一个，就把程序关掉就好了。</p>
<p>一个比较坑的点是，某些绑定在cmd上的系统快捷会与软件的冲突，软件没法使用了,解决方案是使用 autokey 映射cmd + x 到别的已经有的按键绑定，其实本质的按键绑定没有改变<br>比如 cmd + i  映射到 ctrl + `  autokey key还可以使用send 语法发送按键信息，给软件</p>
<p>这是我写好的脚本，基本实现一致的编程体验， 欢迎自取修改<br><a href="https://github.com/Alan110/autokey-mac" target="_blank" rel="external">autokey脚本</a></p>
<p>好了，可以愉快的写代码了，have  fun ！！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[nodejs中的路径]]></title>
      <url>http://http://localhost:4000/2017/06/18/nodejs-path/</url>
      <content type="html"><![CDATA[<h2 id="path-join-和-path-resolve"><a href="#path-join-和-path-resolve" class="headerlink" title="path.join 和 path.resolve"></a>path.join 和 path.resolve</h2><p><code>path.join</code>    是组合给予的路径参数，并使用正确的系统分隔符<br><code>path.resolve</code> 是合并给予的路径参数，并返回绝对路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">path.join(&apos;/a&apos;, &apos;/b&apos;, &apos;c&apos;)      // /a/b/c</div><div class="line"></div><div class="line"></div><div class="line">path.resolve(&apos;/a&apos;, &apos;/b&apos;, &apos;c&apos;)   // /b/c</div></pre></td></tr></table></figure>
<p>所以什么时候应该用哪个，一个比较直观的区别点在于你期望’/‘ 的行为，如果你期望’/‘表现为路径相加，就用path.join , 如果你期望’/‘表现为root路径，则使用path.resolve</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[github/gitlab web-hook]]></title>
      <url>http://http://localhost:4000/2017/06/16/webhook/</url>
      <content type="html"><![CDATA[<p>日常开发场景中，我们可能需要频繁的去线上机器拉取最新git代码，比较繁琐。这些工作可以交给webhook来做。<br>github、gitlab都是支持webhook功能的<br>webhook的意思，就是当我们的仓库发生提交操作时，github、gitlab会往我们预先配置好的地址发送一个请求。从请求中我们可以拿到相应的提交信息，然后判定执行什么操作，比如git pull 或者编译等操作,可以写成shell脚本。<br>所以，我们需要在线上服务器上部署一个监听server，php，nodejs，python等都可以。</p>
<h2 id="webhook-server"><a href="#webhook-server" class="headerlink" title="webhook server"></a>webhook server</h2><p>我用的nodejs，所以找了一个nodejs的webhook模块。这里要注意一下，<strong>gitlab和github是不一样的，所以需要找相应的三方模块</strong>，别弄错了。</p>
<blockquote>
<p>(gitlab-webhook-handler)[<a href="https://github.com/Flying-Ape/gitlab-webhook-handler" target="_blank" rel="external">https://github.com/Flying-Ape/gitlab-webhook-handler</a>]</p>
</blockquote>
<p>基础代码如readme说明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</div><div class="line"><span class="keyword">var</span> createHandler = <span class="built_in">require</span>(<span class="string">'gitlab-webhook-handler'</span>)</div><div class="line"><span class="keyword">var</span> handler = createHandler(&#123; <span class="attr">path</span>: <span class="string">'/webhook'</span> &#125;)</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  handler(req, res, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    res.statusCode = <span class="number">404</span></div><div class="line">    res.end(<span class="string">'no such location'</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;).listen(<span class="number">7777</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Gitlab Hook Server running at http://0.0.0.0:7777/webhook"</span>);</div><div class="line"></div><div class="line">handler.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">  	<span class="built_in">console</span>.error(<span class="string">'Error:'</span>, err.message)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">handler.on(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  	<span class="built_in">console</span>.log(<span class="string">'Received a push event for %s to %s'</span>,</div><div class="line">    event.payload.repository.name,</div><div class="line">    event.payload.ref)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">handler.on(<span class="string">'issues'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  	<span class="built_in">console</span>.log(<span class="string">'Received an issue event for %s action=%s: #%d %s'</span>,</div><div class="line">    event.payload.repository.name,</div><div class="line">    event.payload.action,</div><div class="line">    event.payload.issue.number,</div><div class="line">    event.payload.issue.title)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>注意path参数，为访问路径，在gitlab上面配置webhook信息，配置发送请求的目标地址 ip + path</p>
<p>可以点击下面的test，进行测试。</p>
<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>在拿到的提交信息中，我们可以自己过滤执行不同的操作。比如是哪个分支，提交人是谁等等</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vue2高级技巧-基础能力]]></title>
      <url>http://http://localhost:4000/2017/05/07/vue2-high-fether/</url>
      <content type="html"><![CDATA[<h2 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h2><p>使用name属性, 便可在组件的template中直接使用组件本身, <strong>比如在某些递归的场景就需要如此使用</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;template lang="html"&gt;</div><div class="line">    &lt;li&gt;</div><div class="line">        &lt;item&gt;&lt;/item&gt;</div><div class="line">    &lt;/li&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    import utils from 'utils'</div><div class="line">    export default&#123;</div><div class="line">        name : 'item',</div><div class="line">        props: &#123;</div><div class="line">            model: Object</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="动态切换component"><a href="#动态切换component" class="headerlink" title="动态切换component"></a>动态切换component</h2><p>当我们需要动态切换组件的时候，可以使用内置的component标签，不必写冗余的if else，但是要注意的是，动态切换默认会重新渲染组件，在某些比较费时的组件又需要频繁切换的时候，可以用keep-alive标签使其保持在内存。</p>
<p><strong>动态component其实可以和异步组件，以及vuex数据结合</strong>，实现按需注册并加载使用组件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&lt;component v-<span class="keyword">for</span>=<span class="string">"(layer,index) in curScene.layers"</span> :key=<span class="string">"layer.id"</span> :is=<span class="string">"layer.type"</span> source=<span class="string">"scenebox"</span> :layer=<span class="string">"layer"</span> :index=<span class="string">"index"</span> :layers=<span class="string">"curScene.layers"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 保持组件在内存，不会重新初始化</span></div><div class="line">&lt;keep-alive&gt;</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-for</span>=<span class="string">"(layer,index) in curScene.layers"</span> <span class="attr">:key</span>=<span class="string">"layer.id"</span> <span class="attr">:is</span>=<span class="string">"layer.type"</span> <span class="attr">source</span>=<span class="string">"scenebox"</span> <span class="attr">:layer</span>=<span class="string">"layer"</span> <span class="attr">:index</span>=<span class="string">"index"</span> <span class="attr">:layers</span>=<span class="string">"curScene.layers"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/keep-alive&gt;</span></div></pre></td></tr></table></figure>
<h2 id="v-model-的秘密"><a href="#v-model-的秘密" class="headerlink" title="v-model 的秘密"></a>v-model 的秘密</h2><p>vue的双向数据绑定其实语法糖，通过内部触发input事件，配合指令实现。<br><a href="http://www.cnblogs.com/wwlhome/p/6551165.html" target="_blank" rel="external">http://www.cnblogs.com/wwlhome/p/6551165.html</a></p>
<h2 id="v-for-key"><a href="#v-for-key" class="headerlink" title="v-for key"></a>v-for key</h2><p>用于强制替换元素/组件而不是重复使用它<br>key 是唯一id，不能重复，否则会报致命错误<br>如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。</p>
<p>有子组件的时候，需要加上key</p>
<h2 id="调整数组顺序"><a href="#调整数组顺序" class="headerlink" title="调整数组顺序"></a>调整数组顺序</h2><p>可以使用数组的变异方法splice<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">layers.splice.apply(layers, [toIndex, <span class="number">0</span>].concat(moved = layers.splice(fromIndex, howMany)) )<span class="string">`</span></div></pre></td></tr></table></figure></p>
<h2 id="v-for-和-v-if-需要同时使用时"><a href="#v-for-和-v-if-需要同时使用时" class="headerlink" title="v-for 和 v-if 需要同时使用时"></a>v-for 和 v-if 需要同时使用时</h2><p>使用<template></template>标签替换, <strong>template是一个空标签，没有实际渲染内容，但是可以作为逻辑的载体</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&lt;template  v-<span class="keyword">for</span>=<span class="string">"page in pages"</span> &gt;</div><div class="line">    &lt;tr class="item" v-if="!page.global" :key="page.id"&gt;</div><div class="line">        &lt;td&gt;&lt;img :src="page.global.sceneImgs[0] + '?key=' + randomKey" class="page-thumb"</div><div class="line">                    v-if="page.global.sceneImgs &amp;&amp; page.global.sceneImgs[0]" style="height:100%;" alt=""&gt;&lt;/td&gt;</div><div class="line">        &lt;td&gt;&#123;&#123; page.title &#125;&#125;&lt;/td&gt;&lt;Paste&gt;</div><div class="line">&lt;/templte&gt;</div></pre></td></tr></table></figure>
<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>利用webpack的异步加载模块的能力，和vue的异步注册实现动态组件加载。</p>
<p>异步import返回的是一个promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'widget'</span>,()=&gt; <span class="keyword">import</span>(<span class="string">'./widget/text'</span>));</div></pre></td></tr></table></figure>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a><a href="https://cn.vuejs.org/v2/guide/custom-directive.html#main" target="_blank" rel="external">指令</a></h2><p>在 Vue 中可以把一系列 复杂的操作 包装为一个指令<br>什么是复杂的操作?<br>复杂逻辑功能的包装、违背数据驱动的 DOM 操作以及对一些 Hack 手段的掩盖等。我们总是期望以操作数据的形式来实现功能逻辑。</p>
<p>在vue的指令中是不可以双向数据绑定的，如官方所说：除了 el 之外，其它参数都应该是只读的，尽量不要修改他们。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行</p>
<p>指令可以在钩子函数中去封装dom, 应尽可能的操作当前dom，比如在inserted的时候，当前dom插入文档时<br>如果要操作别的dom就需要等待他们插入文档，此时可以使用nextTick,vnode.context为当前的vue对象</p>
<h3 id="拖拽示例"><a href="#拖拽示例" class="headerlink" title="拖拽示例"></a>拖拽示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Vue.directive(<span class="string">'drag'</span>, &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * value.target = 实际需要移动的dom元素的ref名</div><div class="line">     */</div><div class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding,vnode</span>) </span>&#123;</div><div class="line">        <span class="comment">// 下一帧再获取dom元素</span></div><div class="line">        vnode.context.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="comment">// 实际移动的元素</span></div><div class="line">            <span class="keyword">let</span> moveEl = <span class="keyword">this</span>.$refs[binding.value.target];</div><div class="line">            <span class="comment">// 覆盖下面有监听mousemove的元素，避免干扰</span></div><div class="line">            <span class="keyword">let</span> $mask = $(<span class="string">'&lt;div class="project-mask" style="position: absolute; top : 30px; left: 0; right:0;bottom:0; z-index: 200px; display: none;"&gt;&lt;/div&gt;'</span>).appendTo(moveEl);</div><div class="line">            el.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</div><div class="line">                $mask.show();</div><div class="line">                <span class="keyword">var</span> disX = ev.clientX - moveEl.offsetLeft;</div><div class="line">                <span class="keyword">var</span> disY = ev.clientY - moveEl.offsetTop;</div><div class="line">                <span class="built_in">document</span>.body.focus();</div><div class="line">                <span class="comment">// prevent text selection in IE</span></div><div class="line">                <span class="built_in">document</span>.onselectstart = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</div><div class="line">                <span class="comment">// prevent IE from trying to drag an image</span></div><div class="line">                moveEl.ondragstart = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;;</div><div class="line"></div><div class="line">                <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</div><div class="line">                    <span class="keyword">var</span> l = ev.clientX - disX;</div><div class="line">                    <span class="keyword">var</span> t = ev.clientY - disY;</div><div class="line">                    moveEl.style.left = l + <span class="string">'px'</span>;</div><div class="line">                    moveEl.style.top = t + <span class="string">'px'</span>;</div><div class="line">                &#125;;</div><div class="line">                <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                    $mask.hide();</div><div class="line">                    <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</div><div class="line">                    <span class="built_in">document</span>.onselectstart = <span class="literal">null</span>;</div><div class="line">                    moveEl.ondragstart = <span class="literal">null</span>;</div><div class="line">                    <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</div><div class="line">                &#125;;</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><blockquote>
<p>vuex于eventBus的区别</p>
</blockquote>
<p>vuex = getters + actions + mutations<br>状态管理器，vuex = 全局事件中心 + 全局变量<br>eventBus = 全局事件中心<br>所以vuex更加强大, </p>
<blockquote>
<p>组件通信心得</p>
</blockquote>
<ul>
<li>只是简单的父子组件通信，使用$emit，$on</li>
<li>稍微复杂的跨组件通信使用eventBus</li>
<li>非常复杂的跨组件通信，以及状态切换使用vuex</li>
</ul>
<blockquote>
<p>vuex心得</p>
</blockquote>
<p><strong>在大型复杂的软件架构中，推崇提取组件状态到state成为公共状态</strong>更利于复用，和通信。<br>大型软件架构中<strong>vuex可以拆分成模块，异步注册</strong></p>
<ul>
<li>推荐所有的状态变化都通过mutations来改变。如果1个操作很复杂，或者是公用的，则可提取到action中，action中可以再访问action，或者提交多个commit，以及异步操作。</li>
<li><strong>mutations中的方法，应该尽可能的抽象, 满足尽可能多的情况。</strong></li>
<li>payload应该使用对象，拥有更好的扩展性。</li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[坑-动态插入script不执行]]></title>
      <url>http://http://localhost:4000/2017/03/21/dynamic-insert-script-not-excute/</url>
      <content type="html"><![CDATA[<p>innerHTML 只能插入dom，插入script标签不会执行，用标准dom创建scrip标签可以执行</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[动态打包]]></title>
      <url>http://http://localhost:4000/2017/03/21/dynamic-pack/</url>
      <content type="html"><![CDATA[<p>打包配置是动态生成的，<br>同时内容是根据配置生成的，<br>希望能够内联，<br>希望能分别对资源做prase</p>
<p>所有的编译工具都是静态编译，在编译前，代码都是确定的。输入都是文件，支持动态确定输入的就只有fis 的inline了，可以先让模板引擎编译，然后确定inline, webpack也有require，但是它的入口必须js，同事打包出来的也是js，而我们需要的是一个html</p>
<p>涉及到编译组件的模块化，同时还有js的模块化</p>
<p>后端模板也带了模块化打包的能力，但是没有对特定资源做预处理的能力</p>
<p>编译工具可以对特定资源做处理，但是当先经过了后端模板，就变成了一个整体，就不好单独对资源做处理了。</p>
<p>同时要有能分析依赖的能力</p>
<hr>
<p>后端模板先编译，整体html<br>分离出js，css，分别预编译 (没有写入到文件，那么对于对模块化语法有注入的打包工具就有干扰，只能自己实现模块化)<br>再插入html</p>
<p>主要问题就是后端模板编译的输出和打包工具的输入接不起来</p>
<p>如果能</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[express-learn]]></title>
      <url>http://http://localhost:4000/2017/03/19/express-learn/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[移动端响应式解决方案]]></title>
      <url>http://http://localhost:4000/2017/03/13/move-side-respones/</url>
      <content type="html"><![CDATA[<p>移动端尺寸不一，所以需要一套自适应的方案。<br>需要考虑我们的场景，有些时候，我们只需要宽度按设备尺寸伸缩，纵向上可以是固定的值<br>有时候，我们需要横向，纵向上都能按设备尺寸伸缩，例如铺满屏幕的应用。</p>
<p>为什么移动端会有尺寸适配的问题</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>物理像素(Device Pixels)</p>
</blockquote>
<p>真实物理设备上的像素点, 单位是px，但也是相对的，因为我的点可能比你的点小</p>
<blockquote>
<p>逻辑像素(设备独立像素)</p>
</blockquote>
<p>逻辑像素是一个相对的抽象概念,并不是实际的具体长度。比如css像素，它只是一个单位，具体渲染出来有多大得看设备。</p>
<blockquote>
<p>dpr (Device pixel ratio)</p>
</blockquote>
<ul>
<li>表示每个逻辑像素（css）有几个物理像素</li>
<li>dpr = 物理像素 / css像素</li>
<li>window.devicePixelRatio 可以直接获取</li>
</ul>
<blockquote>
<p>dpi/ppi (Dots Per Inch / Pixel Per Inch)</p>
</blockquote>
<ul>
<li>像素密度，每英寸的像素点个数。</li>
<li>Math.sqrt(750<em>750 + 1334</em>1334) / 4.7 = 326ppi // 屏幕对角线的像素尺寸 / 物理尺寸（inch）</li>
</ul>
<blockquote>
<p>viewport</p>
</blockquote>
<ul>
<li>视口，桌面上视口宽度等于浏览器宽度，也等于css像素，但在手机上有所不同 。 </li>
<li>它也是一个虚拟的概念，因为手机的分辨率高，在没有缩放的情况下，手机上的视口要比屏幕宽度大得多，但它实际尺寸就是屏幕那么大，所以就只好缩小网页，将其容纳于视口之中。</li>
<li><meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">, 所以有了这个经典的meta标签，设置视口width=device-width 。</li>
<li>这也是为什么手机上能双指缩放</li>
</ul>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><h2 id="百分比"><a href="#百分比" class="headerlink" title="百分比"></a>百分比</h2><p>百分比布局只能用在横向上，比如宽度, 并且它是参照父元素的宽度。<br>高度百分比，需要html,body 等一层一层的往下写高度，才能有参照,参照的是父元素的高度</p>
<ul>
<li><strong>需要层层继承父元素的宽，高</strong></li>
<li><strong>但是在高度上使用百分比，在不同机型上会有拉伸效果。比如图片，因为图片的伸缩比例和设备的比例是不同的。</strong></li>
<li><strong>其中有个坑就是margin，padding，它的百分比是参照的父元素的宽度</strong>。 所以用百分比布局，如果要在纵向上自适应，就相当麻烦了。</li>
</ul>
<p>但这个特性可以用来解决<strong>已知图片比例</strong>的自适应问题。<br>因为padding是按父元素的宽度来计算百分比的，在我们知道图片比例的情况下，可以通过padding来根据宽度自适应计算出高度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span>&#123;</div><div class="line">    <span class="attribute">height </span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding-top </span>: <span class="number">75%</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.img</span>&#123;</div><div class="line">    <span class="attribute">position </span>: absolute;</div><div class="line">    <span class="attribute">top </span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">left </span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">width </span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">height </span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="百分比绝对定位"><a href="#百分比绝对定位" class="headerlink" title="百分比绝对定位"></a>百分比绝对定位</h2><p>不需要层层继承父元素的宽，高，只需要参照最外层的定位元素就可以了。<br>缺点就是所有元素都脱离了的文档，采用平面定位的方式来布局。</p>
<h2 id="动态计算rem"><a href="#动态计算rem" class="headerlink" title="动态计算rem"></a>动态计算rem</h2><p>既然要伸缩，就需要一个统一的参照标准，这是最好的。</p>
<p>在rem是参照html元素的字体大小, 可以做到所有元素有统一的参照。</p>
<p>不过rem的布局，在缩小时不一定能完全按比例缩小。</p>
<p>rem 默认是1rem=16px </p>
<blockquote>
<p>rem的换算</p>
</blockquote>
<p>手机上的分辨率高，一个css像素点往往是几个物理像素点组成, 所以ue给的psd量的尺寸需要经过换算，</p>
<p>iPhone6  375设备宽度   750设计稿宽度 正好是2倍<br>6s 414设备宽度 1125设计稿宽度 3倍</p>
<p>下面是一个用js动态计算html的rem的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">setResponseRem</span>(<span class="params">basePx, width</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> doc = <span class="built_in">document</span>,</div><div class="line">        win = <span class="built_in">window</span>,</div><div class="line">        docEl = doc.documentElement,</div><div class="line">        resizeEvt = <span class="string">'orientationchange'</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">'orientationchange'</span> : <span class="string">'resize'</span>,</div><div class="line">        timer = <span class="literal">null</span>,</div><div class="line"></div><div class="line">        recalc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            clearTimeout(timer);</div><div class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> viewportWidth = docEl.getBoundingClientRect().width || docEl.clientWidth;</div><div class="line">                <span class="keyword">if</span> (!viewportWidth) <span class="keyword">return</span>;</div><div class="line">                docEl.style.fontSize = basePx * (viewportWidth / width) + <span class="string">'px'</span>;</div><div class="line">            &#125;, <span class="number">10</span>);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    recalc();</div><div class="line"></div><div class="line">    win.addEventListener(resizeEvt, recalc, <span class="literal">false</span>);</div><div class="line">&#125;)(<span class="number">100</span>,<span class="number">750</span>);</div></pre></td></tr></table></figure>
<p> rem自适应，css=实际图的px / 100<br> basePx : 100 ,换算基准, 1rem等于多少px，这个值可以随意定，因为后续px换算rem时会除以这个值，设为100只是为了方便计算<br> width : 750 代表设计稿宽度<br> viewportWidth : 代表设备宽度，css像素<br> viewportWidth / width : 缩放比例, 其实就 1/dpr<br> fontSize : 实际的html上的字体大小</p>
<p> 我们的换算基准是固定的，缩放的任务交给了rem</p>
<h2 id="动态计算meta标签"><a href="#动态计算meta标签" class="headerlink" title="动态计算meta标签"></a>动态计算meta标签</h2><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;/&gt;</code><br>从前面的viewport的知识，我们知道，viewpoint是可以进行缩放的，一般情况下，我只是把viewpoint设置成了设备的css宽度，并且没有缩放。通过rem动态计算来实现缩放。其实也可以用它来实现响应式缩放。<br>通过js计算出当前设备的dpr<br>scale = 1 / dpr<br>动态设置meta标签的scale缩放程度。</p>
<p>rem我们也用，只不过它只是作为一个写法标准，缩放的任务是交给了meta 标签的scale属性。</p>
<blockquote>
<p><a href="http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="external">lib-flexable</a></p>
</blockquote>
<p>这是淘宝沉淀的自适应方案，就是采用动态计算meta标签和rem，来做的。</p>
<p>原理 ：</p>
<ol>
<li>默认也是使用viewpoint缩放 + rem 实现， 字体是另外一套缩放方案，根据dpr倍数缩放</li>
<li>只兼容了ios, 安卓的dpr都是1，看起来没什么问题。</li>
</ol>
<p>注意:</p>
<ol>
<li><p>如果是瀑布流式的页面，使用此方案没有什么问题，字体可以按dpr倍数缩放，小大机型上看到的文字更多。如果是<strong>绝对定位的页面</strong>，那就不能使用dpr方案缩放文字，<strong>只能用rem</strong>，原因是dpr倍数缩放会保证文字的大小在所有机型上一致，但是文字和绝对定位的top，rem 将不能匹配。如果是大段文字，拆分成几个绝对定位元素拼接，那么位置对齐就会有问题。</p>
</li>
<li><p>如果是瀑布流式页面，使用此方案没问题，如果是<strong>全屏覆盖的翻页场景</strong>，此方案图片缩放会有问题，高度上的缩放可能会超出1屏幕, <strong>流式页面可以滚动</strong>，所以没问题。</p>
</li>
</ol>
<h2 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h2><p>弹性布局对移动端比较友好，功能比inline-block强大，在横向上的布局，建议用flexbox<br>移动端兼容，建议使用autoprefix</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-class">.f-box</span>&#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">flex-wrap</span>: nowrap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.f-box-cld</span>&#123;</div><div class="line">  <span class="attribute">flex </span>: <span class="number">1</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">40%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[webstorm-learn]]></title>
      <url>http://http://localhost:4000/2017/03/13/webstorm-learn/</url>
      <content type="html"><![CDATA[<h2 id="未经授权报错"><a href="#未经授权报错" class="headerlink" title="未经授权报错"></a>未经授权报错</h2><p>访问sass编译后的css，出现警告。<br><img src="http://p1.bpimg.com/567571/79b8a3afeb43ff83.png" alt="pic alt" title="opt title"></p>
<p>设置允许非法请求<br><img src="http://p1.bpimg.com/567571/b810bf7626dfe381.png" alt="pic alt" title="opt title"></p>
<h2 id="vue中scss报错"><a href="#vue中scss报错" class="headerlink" title="*.vue中scss报错"></a>*.vue中scss报错</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;style lang=&apos;scss&apos; rel=&apos;stylesheet/scss&apos;&gt;&lt;/style&gt;</div></pre></td></tr></table></figure>
<p>添加<code>rel=stylesheet/scss</code></p>
<h2 id="手机访问内置server"><a href="#手机访问内置server" class="headerlink" title="手机访问内置server"></a>手机访问内置server</h2><p><img src="http://p1.bpimg.com/567571/6eb329c840332e54.png" alt="pic alt" title="opt title"></p>
<p>注意端口需要修改，63342是默认端口。</p>
<h2 id="配置动态编译scss"><a href="#配置动态编译scss" class="headerlink" title="配置动态编译scss"></a>配置动态编译scss</h2><p>添加file watcher <a href="https://www.jetbrains.com/help/webstorm/2016.3/transpiling-sass-less-and-scss-to-css.html#d253312e140" target="_blank" rel="external">官方文档</a><br>注意sass需要使用 <strong>gem</strong> 安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo gem install sass</div></pre></td></tr></table></figure>
<p>gem env 可以查看包的位置</p>
<blockquote>
<p>编译中文乱码</p>
</blockquote>
<p> 关于使用gulp压缩sass中文乱码问题：Invalid US-ASCII character “\xE5”) </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cd /Library/Ruby/Gems/2.0.0/gems/sass-3.4.23/lib/sass</div><div class="line">sudo vim engine.rb</div></pre></td></tr></table></figure>
<p>添加一行 <code>Encoding.default_external = Encoding.find(&#39;utf-8&#39;)</code>, 在require的后面</p>
<h2 id="window下watch失效"><a href="#window下watch失效" class="headerlink" title="window下watch失效"></a>window下watch失效</h2><p>  <img src="http://i2.muimg.com/567571/9ea5c3c38362f3f5.png" alt="pic alt" title="opt title"></p>
<p>  把safe_write选项去掉</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[webuploader入门指南]]></title>
      <url>http://http://localhost:4000/2017/03/11/webuploader-learn/</url>
      <content type="html"><![CDATA[<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-class">.webuploader-container</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.webuploader-element-invisible</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute <span class="meta">!important</span>;</div><div class="line">    <span class="attribute">clip</span>: <span class="built_in">rect</span>(1px 1px 1px 1px); <span class="comment">/* IE6, IE7 */</span></div><div class="line">    <span class="attribute">clip</span>: <span class="built_in">rect</span>(1px,1px,1px,1px);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.webuploader-pick</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">cursor</span>: pointer;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#00b7ee</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">15px</span>;</div><div class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.webuploader-pick-hover</span> &#123;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#00a2d4</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.webuploader-pick-disable</span> &#123;</div><div class="line">    <span class="attribute">opacity</span>: <span class="number">0.6</span>;</div><div class="line">    <span class="attribute">pointer-events</span>:none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些css是预定义钩子，用来重置input的样式和一些状态下的样式，可以自己定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> uploader = WebUploader.create(&#123;</div><div class="line">    <span class="attr">auto</span>: <span class="literal">true</span>, <span class="comment">// 选择完毕后自动上传</span></div><div class="line">    swf: <span class="string">'path_of_swf/Uploader.swf'</span>,</div><div class="line">    <span class="attr">pick</span> :&#123;</div><div class="line">        <span class="attr">id</span>: <span class="string">'#filePicker'</span>,</div><div class="line">        <span class="attr">label</span>: <span class="string">'点击选择图片'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">chunked</span> : <span class="literal">true</span>, </div><div class="line">    <span class="attr">threads</span> : <span class="number">1</span>, <span class="comment">// 设置并发请求数</span></div><div class="line">    duplicate : <span class="literal">true</span>, <span class="comment">// 默认不能上传重复的文件</span></div><div class="line">    chunkSize : <span class="number">1.7</span> * <span class="number">1024</span> * <span class="number">1024</span>, <span class="comment">// 分片大小</span></div><div class="line">    server: <span class="string">'../../server/fileupload.php'</span>,</div><div class="line">    <span class="attr">accept</span> : &#123;</div><div class="line">        <span class="attr">title</span>: <span class="string">'Images'</span>,</div><div class="line">        <span class="attr">extensions</span>: <span class="string">'gif,jpg,jpeg,bmp,png'</span>,</div><div class="line">        <span class="attr">mimeTypes</span>: <span class="string">'image/*'</span>, <span class="comment">// 改成具体的接受类型，否则会有变得延迟的问题</span></div><div class="line">        compress : <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="http://fex.baidu.com/webuploader/doc/index.html#WebUploader_Uploader_md5File" target="_blank" rel="external">详细Api</a></p>
<h2 id="携带自定义参数"><a href="#携带自定义参数" class="headerlink" title="携带自定义参数"></a>携带自定义参数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 初始化的时候直接添加  </span></div><div class="line"><span class="keyword">var</span> uploader = <span class="keyword">new</span> WebUploader.Uploader(&#123;  </div><div class="line">    ...  </div><div class="line">    formData: &#123;  </div><div class="line">        <span class="attr">uid</span>: <span class="number">123</span>  </div><div class="line">    &#125;  </div><div class="line">    ...  </div><div class="line">&#125;);  </div><div class="line">  </div><div class="line"><span class="comment">// 初始化以后添加  </span></div><div class="line">uploader.options.formData.uid = <span class="number">123</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>局部设置</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">uploader.on( <span class="string">'uploadBeforeSend'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> block, data </span>) </span>&#123;  </div><div class="line">    <span class="comment">// block为分块数据。  </span></div><div class="line">  </div><div class="line">    <span class="comment">// file为分块对应的file对象。  </span></div><div class="line">    <span class="keyword">var</span> file = block.file;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="comment">// 修改data可以控制发送哪些携带数据。  </span></div><div class="line">    data.uid = <span class="number">123</span>;  </div><div class="line">    data.formData = &#123;&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="关键事件点"><a href="#关键事件点" class="headerlink" title="关键事件点"></a>关键事件点</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">uploader.on(<span class="string">'fileQueued'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</div><div class="line">    </div><div class="line">  uploader.md5File( file )</div><div class="line"></div><div class="line">        <span class="comment">// 及时显示进度</span></div><div class="line">        .progress(<span class="function"><span class="keyword">function</span>(<span class="params">percentage</span>) </span>&#123;</div><div class="line">            <span class="comment">//console.log('Percentage:', percentage);</span></div><div class="line">        &#125;)</div><div class="line"></div><div class="line">        <span class="comment">// 完成</span></div><div class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'md5 result:'</span>, val);</div><div class="line">            uploader.option.formData.md5 = val;</div><div class="line">            uploader.upload();</div><div class="line">        &#125;);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">uploader.on(<span class="string">'uploadBeforeSend'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">block , data</span>) </span>&#123;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">uploader.on(<span class="string">'uploadProgress'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">file , percentage</span>) </span>&#123;</div><div class="line">    </div><div class="line">&#125;)</div><div class="line"></div><div class="line">uploader.on(<span class="string">'uploadSuccess'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">file ,response</span>) </span>&#123;</div><div class="line">    </div><div class="line">&#125;)</div><div class="line"></div><div class="line">uploader.on(<span class="string">'uploadError'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">file ,reason</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(reason);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[模板文件数据Api可视化抽象]]></title>
      <url>http://http://localhost:4000/2017/03/02/ApiDataAbstraction/</url>
      <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>通过可视化生成模板文件</p>
<p>当这个模板文件涉及到后端数据交互的时候，这个就很难抽象了，因为API无法抽象确定，每次都可能是唯一的。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>我们根据后端返回的结果，确定占位符，然后交给前端可视化工具，在数据结果层面做占位符映射，而不在输入层面做占位符映射，因为无法穷举。</p>
<p><img src="http://p1.bqimg.com/567571/4ca04cd67e304b66.png" alt="pic alt" title="opt title"></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack2 经验教程]]></title>
      <url>http://http://localhost:4000/2017/02/26/webpack2-x-learn/</url>
      <content type="html"><![CDATA[<p>webpack2的文档好了很多，常用配置都有，所以熟读官方文档是最好的学习方式。 <a href="https://webpack.js.org/configuration/" target="_blank" rel="external">传送门</a></p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com/FvBo_6LhVku9AzB0_UPAOpD4fIdc" alt=""></p>
<p>这里介绍一下官方文档内容分布。</p>
<ul>
<li>CONCEPTS : 一些常用概念的介绍</li>
<li><strong>GUIDES</strong> : 打包能力介绍，以及涉及的配置</li>
<li>DOCUMENTATION : 从不同维度详细介绍如何配置webpack</li>
</ul>
<p>所以看文档的顺序是，先确定你要做什么，它是属于什么概念范围的配置，然后去GUIDES中寻找，然后去DOCUMENTATION中寻找详细的配置<br><strong>GUIDES 是webpack的配置能力精华，是总纲。应该要最熟悉</strong></p>
<h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><h2 id="code-spilit"><a href="#code-spilit" class="headerlink" title="code-spilit"></a>code-spilit</h2><blockquote>
<p><a href="https://webpack.js.org/api/module-methods/#import-" target="_blank" rel="external">异步模块加载</a></p>
</blockquote>
<p>在webpack2中，可以使用es6的import实现异步加载模块，它可以返回promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span>(</div><div class="line">  <span class="comment">/* webpackChunkName: "my-chunk-name" */</span></div><div class="line">  <span class="comment">/* webpackMode: "lazy" */</span></div><div class="line">  <span class="string">'module'</span></div><div class="line">).then(<span class="function">(<span class="params"><span class="built_in">module</span></span>)=&gt;</span>&#123;</div><div class="line">    <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">module</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>import支持魔法注释，通过注释，可以配置如何加载模块。</p>
<ul>
<li>webpackChunkName : 指定要打包进的chunk名</li>
<li>webpackMode : 打包的模式</li>
</ul>
<p>webpackMode </p>
<ul>
<li>lazy  // default , 会为<strong>每个异步模块</strong>，单独打包。如果指定了相同的chunkName,会在后面带上数字区分</li>
<li><strong>lazy-one</strong> // 只打包1次，所有的模块会被打包进相同的chunk, 引入时只会请求一次</li>
<li>eager  // 不生成额外的chunk，会被合并到当前所在chunk</li>
<li>weak // 会重复加载，已经加载过的模块</li>
</ul>
<p>注意:</p>
<ul>
<li>import是支持动态加载路径模块的，<code>import(foo)</code>,但如果路径是完全的变量是不支持的，因为webpack不知道这个文件在哪儿。import(<code>./locale/${language}.json</code>),<strong>webpack是可以运行时确认要加载的模块</strong>，在打包时会把这个路径下的所有模块都打包。</li>
</ul>
<blockquote>
<p>commonChunks</p>
</blockquote>
<p>这个插件可以提取多个入口的公共模块代码，如果有hash的话，要注意再运行一次提取出公共 模块加载代码，否则每次内容改变，hash改变，重复代码又会提取一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// split vendor js into its own file</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'vendor'</span>,</div><div class="line">      <span class="attr">minChunks</span>: <span class="function"><span class="keyword">function</span> (<span class="params">module, count</span>) </span>&#123;</div><div class="line">        <span class="comment">// any required modules inside node_modules are extracted to vendor</span></div><div class="line">        <span class="keyword">return</span> (</div><div class="line">          <span class="built_in">module</span>.resource &amp;&amp;</div><div class="line">          <span class="regexp">/\.js$/</span>.test(<span class="built_in">module</span>.resource) &amp;&amp;</div><div class="line">          (<span class="built_in">module</span>.resource.indexOf( path.join(__dirname, <span class="string">'../node_modules'</span>)) === <span class="number">0</span> ||</div><div class="line">           <span class="built_in">module</span>.resource.indexOf( path.join(__dirname, <span class="string">'../src/common/vendor'</span>)) === <span class="number">0</span>)</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    <span class="comment">// extract webpack runtime and module manifest to its own file in order to</span></div><div class="line">    <span class="comment">// prevent vendor hash from being updated whenever app bundle is updated</span></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'manifest'</span>,</div><div class="line">      <span class="attr">chunks</span>: [<span class="string">'vendor'</span>]</div><div class="line">    &#125;),</div></pre></td></tr></table></figure>
<blockquote>
<p>tree shaking</p>
</blockquote>
<h2 id="非npm的三方模块引入"><a href="#非npm的三方模块引入" class="headerlink" title="非npm的三方模块引入"></a>非npm的三方模块引入</h2><blockquote>
<p>import-loader</p>
</blockquote>
<p>如果第三方模块依赖window作为this，则用此模式</p>
<blockquote>
<p>exports-loader</p>
</blockquote>
<p>如果第三方模块导出的是全局变量，可以用此模式，比如jQuery</p>
<blockquote>
<p>script-loader</p>
</blockquote>
<p>如果第三方模块比较老旧，可以用这中方式，在全局作用域执行</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack1.x 入门教学]]></title>
      <url>http://http://localhost:4000/2017/02/22/webpack-learn/</url>
      <content type="html"><![CDATA[<p><img src="http://webpackdoc.com/images/what-is-webpack.png" alt="pic alt" title="opt title"></p>
<p>webpack 是一个包含预编译/动态加载的<strong>模块化方案</strong>.  会将各种依赖的资源最后打包成1个或者几个文件, 适合单页应用</p>
<p>它与gulp，fis3是有本质区别的，它本质上是模块化方案对应requirejs之类的，主要能力是打包，只不过包含了部分构建的能力。它可以作为gulp中的task,负责打包工作。</p>
<p>webpack 可以支持AMD，CMD，UMD的打包, <strong>请注意如果代码复杂度没有涉及到模块化，那么完全不需要用webpack，比如简单的运营页面，自己做好简单的模块化就行了。因为webpack的优势在这里根本用不上</strong> , 这种情况推荐用gulp。</p>
<p><strong>单入口的情况下，不管重复require多少次一个模块，都只会打包一次。</strong><br><strong>多入口实际就是分别执行多个单入口，彼此之间不影响, 如果都引入同一个模块，会被引入多次</strong></p>
<p>CommonsChunkPlugin解决了这个问题, 就是把多个入口共同的依赖都给定义成 一个新入口</p>
<h2 id="核心概念解析"><a href="#核心概念解析" class="headerlink" title="核心概念解析"></a>核心概念解析</h2><blockquote>
<p>loader</p>
</blockquote>
<p><strong>webpack本身只能处理commonjs规范的js文件</strong>，如果要处理其他文件，就要使用相应的loader进行转换。<br>是针对于资源文件转换成commonjs文件，可以理解为预处理转换器<br>loader 可以通过!传递流，通过?传递参数，或者单独配置query参数</p>
<blockquote>
<p>plugn</p>
</blockquote>
<p>plugn是扩展webpack本身的能力 , 是在整个构建过程中都生效的，不要和loader搞混淆了。</p>
<blockquote>
<p>chunkId/mouleId</p>
</blockquote>
<p>webpack的id 有两种 一种为 chunkid 一种为moduleId<br>每个chunkid 对应的是一个js文件<br>每个moduleid对应的是一个内容模块，一个js文件可以包含多个内容模块<br>为何要出来一个chunkid呢？ 这个chunkid的作用就是，标记这个js文件是否已经加载过了</p>
<blockquote>
<p>HMR</p>
</blockquote>
<p>热插拔, 其本质上是一个插件, 作用是修改后自动刷新浏览器。 它有2种启动方式</p>
<p>CLI (推荐)</p>
<p><code>webpack-dev-server --hot --inline</code></p>
<p>cfg</p>
<p><img src="http://p1.bqimg.com/567571/f4129450f02c59ce.png" alt=""></p>
<h2 id="配置文件接口-官方插件接口"><a href="#配置文件接口-官方插件接口" class="headerlink" title="配置文件接口 / 官方插件接口"></a><a href="http://webpack.github.io/docs/configuration.html#output-chunkfilename" target="_blank" rel="external">配置文件接口</a> / <a href="http://webpack.github.io/docs/list-of-plugins.html" target="_blank" rel="external">官方插件接口</a></h2><p>配置写在webpack.conf.js, 可以在官网查询到所有的配置项</p>
<p><img src="http://p1.bpimg.com/567571/af938cd7c72d71f7.png" alt="pic alt" title="opt title"></p>
<blockquote>
<p>异步加载模块</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这是编译后的代码<br><img src="http://i1.piimg.com/567571/d62cf7c9f9a246d1.png" alt="pic alt" title="opt title"></p>
<h2 id="常见配置解析"><a href="#常见配置解析" class="headerlink" title="常见配置解析"></a>常见配置解析</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);  <span class="comment">// 包含一些自带的插件，使用时需要引入</span></div><div class="line"><span class="keyword">var</span> HtmlwebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);  <span class="comment">// 第三方插件需要安装，并引入</span></div><div class="line"><span class="keyword">var</span> OpenBrowserPlugin = <span class="built_in">require</span>(<span class="string">'open-browser-webpack-plugin'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> TEM_PATH = path.resolve(ROOT_PATH, <span class="string">'templates'</span>); <span class="comment">// 模板文件路径</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line"></div><div class="line">  <span class="attr">entry</span>: &#123; <span class="comment">// 可以有多个入口</span></div><div class="line">	<span class="string">'main'</span> : <span class="string">'main.js'</span>,</div><div class="line">	<span class="string">'main2'</span> : <span class="string">'main2.js'</span>,</div><div class="line">	<span class="string">'vender'</span> : [<span class="string">'jqeury'</span>, <span class="string">'vue'</span>]</div><div class="line">  &#125;, </div><div class="line"></div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span> : path.resolve(__dirname,<span class="string">'dist'</span>), <span class="comment">// 打包后资源的输出路径</span></div><div class="line">    filename: <span class="string">'bundle.js'</span>, <span class="comment">// 输出单文件，如果是多入口按文件名分文件打包则，顺带添加hash，[name].[hash].js , 如果不这么写，由于输出名一样，文件会被覆盖</span></div><div class="line">    publicPath :  <span class="string">''</span> <span class="comment">// 替换资源url，src的时候的路径，线上访问的时候，比如访问cdn文件的时候</span></div><div class="line">    pathinfo : <span class="literal">true</span> <span class="comment">// 添加模块的注释信息,配合eval使用</span></div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">loaders</span>:[ <span class="comment">// 针对资源文件</span></div><div class="line">      <span class="comment">// npm install --save-dev babel-loader babel-core babel-preset-es2015  babel-preset-react  编译jsx</span></div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.js[x]?$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">'babel-loader?presets[]=es2015&amp;presets[]=react'</span> &#125;, <span class="comment">// 简写  使用es6</span></div><div class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style-loader!css-loader?modules|post-loader'</span> &#125;, <span class="comment">// 将css文件插入dom</span></div><div class="line">      &#123; <span class="comment">// 可读性好的写法</span></div><div class="line">        test: <span class="regexp">/\.png$/</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">"url-loader"</span>,  <span class="comment">// 将图片转换成base64</span></div><div class="line">        query: &#123; <span class="attr">mimetype</span>: <span class="string">"image/png"</span> &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">resolve</span> : &#123;   </div><div class="line"></div><div class="line">    <span class="attr">extensions</span>: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>], <span class="comment">// 设置需要识别的扩展文件名 ，设置了此项后会覆盖默认的配置</span></div><div class="line"></div><div class="line">    modules: [   <span class="comment">// 类似nodejs的引用方式，当require一个模块，可以直接写相对路径</span></div><div class="line">	    resolve(<span class="string">'src'</span>),</div><div class="line">	    resolve(<span class="string">'node_modules'</span>)</div><div class="line">    ],</div><div class="line"></div><div class="line"></div><div class="line">	<span class="attr">alias</span> : &#123;  <span class="comment">// 设置路径别名</span></div><div class="line">		lib : <span class="string">'/util/head/lib'</span></div><div class="line">	&#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">externals</span>: &#123; <span class="comment">// 遇到require这些时, 不需要再编译. 适合那些常用的库, 已经在页面通过&lt;script&gt;引入了, 就无需都打包到一起了 , 全局变量申明</span></div><div class="line">      jquery: <span class="string">'jQuery'</span>,</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">postcss</span>: [</div><div class="line">      <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</div><div class="line">  ],</div><div class="line"></div><div class="line">  <span class="attr">devtool</span> : <span class="string">'eval'</span> ,  <span class="comment">// 有7中模式，eval速度最快, 建议开发的时候使用</span></div><div class="line"></div><div class="line">  plugins: [ <span class="comment">// 扩展webpack能力</span></div><div class="line"></div><div class="line">    <span class="keyword">new</span> HtmlwebpackPlugin(&#123;   <span class="comment">// 生产html文件，自动插入构建完成的bundle文件</span></div><div class="line">        title: <span class="string">'Hello World app'</span>,</div><div class="line">        <span class="attr">template</span>: path.resolve(TEM_PATH, <span class="string">'index.html'</span>),</div><div class="line">        <span class="attr">filename</span>: <span class="string">'index.html'</span>,</div><div class="line">        <span class="attr">chunks</span>: [<span class="string">'app'</span>, <span class="string">'vendors'</span>],  <span class="comment">//chunks这个参数告诉插件要引用entry里面的哪几个入口</span></div><div class="line">        inject: <span class="string">'body'</span> <span class="comment">//要把script插入到标签里</span></div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="keyword">new</span> OpenBrowserPlugin(&#123;</div><div class="line">      <span class="attr">url</span>: <span class="string">'http://localhost:8080'</span></div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;       <span class="comment">// 混淆代码</span></div><div class="line">      compress: &#123;</div><div class="line">        <span class="attr">warnings</span>: <span class="literal">false</span></div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123; <span class="comment">// 让模块变成全局模块,不用每次都require, 只要发现有引用就会当成依赖传入</span></div><div class="line">      $: <span class="string">"jquery"</span>,</div><div class="line">      <span class="attr">jQuery</span>: <span class="string">"jquery"</span>,</div><div class="line">      <span class="string">"window.jQuery"</span>: <span class="string">"jquery"</span></div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;  <span class="comment">// 提取公共部分为trunk文件,  所以在浏览器中加载的话，必须先加载 common.js names: ['vendor'], // 成为一个新的入口 filename: "commons.js", // the filename of the commons chunk</span></div><div class="line">        trunks : [<span class="string">'main'</span>,<span class="string">'main2'</span>] <span class="comment">// 指定对那些入口进行提取，默认是对所有入口</span></div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),   <span class="comment">// 热插拔, 修改后自动刷新浏览器，有配置文件，和cli2中方式</span></div><div class="line">    <span class="keyword">new</span> webpack.NoErrorsPlugin(), <span class="comment">//在打包时不会因为错误而中断</span></div><div class="line"></div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="comment">// 可以定义编译时的全局变量，有很多库（React, Vue等）会根据 NODE_ENV 这个变量来判断当前环境。为了尽可能减少包大小，在生产环境中要定义当前环境变量</span></div><div class="line">        __DEV__: <span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>.parse(process.env.DEBUG || <span class="string">'false'</span>))</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">/*optimize.OccurrenceOrderPlugin: 可以减少文件大小</span></div><div class="line"></div><div class="line">    optimize.DedupePlugin: 可以减少重复文件数</div><div class="line"></div><div class="line">    ExtractTextPlugin: 可以将所有css文件打包到一个css文件中*/</div><div class="line">  ]</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="开发-调试技巧"><a href="#开发-调试技巧" class="headerlink" title="开发/调试技巧"></a>开发/调试技巧</h2><p><code>进度和颜色</code><br>当项目逐渐变大，webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色。<br>webpack –progress –colors</p>
<p><code>监听增量编译</code><br>webpack –progress –colors –watch</p>
<blockquote>
<p>调试服务器<a href="http://webpack.github.io/docs/webpack-dev-server.html" target="_blank" rel="external">webpack-dev-server</a></p>
</blockquote>
<p>启动一个 express 静态资源 web 服务器，并且会以监听模式自动运行 webpack<br>webpack-dev-server –progress –colors</p>
<ul>
<li><p>用webpack-dev-server生成bundle.js文件是在内存中的，并没有实际生成；</p>
</li>
<li><p>如果引用的文件夹中已经有bundle.js就不会自动刷新了，你需要先把bundle.js文件手动删除（后期有插件可以完成）</p>
</li>
<li><p>webpack-dev-server –content-base build/   指定server的根目录，不指定则为当前目录</p>
</li>
<li><p>–devtool eval：为你的代码创建source map。当有任何报错的时候可以让你更加精确地定位到文件和行号</p>
</li>
<li><p>如果webpack使用的1.x的版本，那么webpack-dev-server也要使用1.x的版本，否则会报如下错误：Connot find module ‘webpack/bin/config-yargs’。</p>
</li>
<li><p>如果已经有一个工程中使用了webpack-dev-server，并且在运行中，没有关掉的话，那么8080端口就被占用了，此时如果在另一个工程中使用webpack-dev-server就会报错：Error: listen EADDRINUSE 127.0.0.1:8080。*</p>
</li>
</ul>
<blockquote>
<p><a href="http://sanwen.net/a/ltjldpo.html" target="_blank" rel="external">sourceMap</a></p>
</blockquote>
<p>webpack 支持7中sourceMap方式</p>
<p>模式    解释<br>eval    每个module会封装到 eval 里包裹起来执行，并且会在末尾追加注释 //@ sourceURL.<br>source-map  生成一个SourceMap文件.<br>hidden-source-map   和 source-map 一样，但不会在 bundle 末尾追加注释.<br>inline-source-map   生成一个 DataUrl 形式的 SourceMap 文件.<br>eval-source-map 每个module会通过eval()来执行，并且生成一个DataUrl形式的SourceMap.<br>cheap-source-map    生成一个没有列信息（column-mappings）的SourceMaps文件，不包含loader的 sourcemap（譬如 babel 的 sourcemap）<br>cheap-module-source-map 生成一个没有列信息（column-mappings）的SourceMaps文件，同时 loader 的 sourcemap 也被简化为只包含对应行的。</p>
<p><code>排查错误</code></p>
<p>webpack –display-error-details</p>
<p><code>HMR</code> 热替换<br>webpack-dev-server –hot –inline</p>
<p>这个在跨平台开发或者较复杂的项目中特别有用，比如我有个层级很深的操作，操作了10多次才进入这个界面，这个时候更改了一个小功能，如果没有热替换，只能刷新整个页面，再重复操作10多次才能看到效果，热替换改变了这一切</p>
<p><code>使用绝对路径</code><br>Webpack 中涉及路径配置最好使用绝对路径，建议通过<br><code>path.resolve(__dirname, &quot;app/folder&quot;)</code> 或<br><code>path.join(__dirname, &quot;app&quot;, &quot;folder&quot;)</code> 的方式来配置，以兼容 Windows 环境。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://github.com/ruanyf/webpack-demos#demo01-entry-file-source" target="_blank" rel="external">阮一峰webpack入门项目</a><br><a href="http://cnodejs.org/topic/5867bb575eac96bb04d3e301" target="_blank" rel="external">CommonsChunkPlugin解析</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[hadoop入门解惑]]></title>
      <url>http://http://localhost:4000/2017/02/15/hadoop-start/</url>
      <content type="html"><![CDATA[<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构,用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。</p>
<p>Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。</p>
<p>可以把它想象成一个云端的服务接口。</p>
<h2 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h2><p>Hadoop MapReduce is a software framework for easily writing applications which process vast amounts of data (multi-terabyte data-sets) in-parallel on large clusters (thousands of nodes) of commodity hardware in a reliable, fault-tolerant manner.</p>
<p>A MapReduce job usually splits the input data-set into independent chunks which are processed by the map tasks in a completely parallel manner. The framework sorts the outputs of the maps, which are then input to the reduce tasks. Typically both the input and the output of the job are stored in a file-system. The framework takes care of scheduling tasks, monitoring them and re-executes the failed tasks.</p>
<p>Typically the compute nodes and the storage nodes are the same, that is, the MapReduce framework and the Hadoop Distributed File System (see HDFS Architecture Guide) are running on the same set of nodes. This configuration allows the framework to effectively schedule tasks on the nodes where data is already present, resulting in very high aggregate bandwidth across the cluster.</p>
<p>The MapReduce framework consists of a single master JobTracker and one slave TaskTracker per cluster-node. The master is responsible for scheduling the jobs’ component tasks on the slaves, monitoring them and re-executing the failed tasks. The slaves execute the tasks as directed by the master.</p>
<p>Minimally, applications specify the input/output locations and supply map and reduce functions via implementations of appropriate interfaces and/or abstract-classes. These, and other job parameters, comprise the job configuration. The Hadoop job client then submits the job (jar/executable etc.) and configuration to the JobTracker which then assumes the responsibility of distributing the software/configuration to the slaves, scheduling tasks and monitoring them, providing status and diagnostic information to the job-client.</p>
<p>Although the Hadoop framework is implemented in JavaTM, MapReduce applications need not be written in Java.</p>
<p>Hadoop Streaming is a utility which allows users to create and run jobs with any executables (e.g. shell utilities) as the mapper and/or the reducer.<br>Hadoop Pipes is a SWIG- compatible C++ API to implement MapReduce applications (non JNITM based).</p>
<hr>
<p>hadoop MapReduce 是一个为了更简单的编写，大数据集，大量节点并行计算应用的软件框架，它使得硬件可靠，高容错性。</p>
<p>一个 MapReduce job 通常 将输入数据集划分成多个独立的数据块，便于map任务的并行计算，管理。MapReduce对map的结果进行排序，传递给reduce任务。通常，输入和输出都存在一个文件系统。Mapreduce 关心人物分配，监控和重执行失败的任务。</p>
<p>通常，计算节点和存储节点是同一个地方，这就是MapReduce框架和Hadoop的分布式文件系统HDFS，跑在了这些节点上。通过配置，可以高效的任务调度当前数据存在的节点，跨节点的高带宽传输计算结果。</p>
<p><strong>MapReduce框架由一个JobTracker 和每个计算节点上的TaskTracker(奴隶机)</strong> 组成。JobTracker负责调度job的分片任务到相关的奴隶机上。监控他们，并且重新执行失败的任务。奴隶机执行任务，就好像由master执行的一样。</p>
<p><strong>简单来说，MapReduce 应用指定输入输出路径，以及通过使用合适的接口或者抽象类实现map 和reduce方法。</strong>job有很多参数，形成了job的配置。Hadoop job 客户端提交job。使得JobTracker分发程序和配置到奴隶机上，并且任务调度，监控他们。同时提供状态信息给job客户端</p>
<p><strong>虽然Hadoop是用java写的，但是MapReduce程序可以用任意语言来实现。</strong><br>Hadoop提供了2种额外的接口<br>Hadoop Streaming   unix标准输入输出(只支持文本)<br>Hadoop Pipes  c++接口</p>
<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>分布式文件系统, 可以把它想象成一个云端的公用硬盘, 存放我们的输入，输出和中间计算结果。</p>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>是一个经典的编程模型,利用分而治之的思想<br>map是分，reduce是合的概念。将整体抽象为相同行为的个体分别计算，然后将他们合并。</p>
<p>只需要一个数据单元就可以进行的运算在Map方法中实现。<br>需要多个数据单元才能进行的运算在Reduce方法中实现。</p>
<h2 id="hadoop-String"><a href="#hadoop-String" class="headerlink" title="hadoop String"></a>hadoop String</h2><h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[vue是什么]]></title>
      <url>http://http://localhost:4000/2017/02/13/what-is-vue/</url>
      <content type="html"><![CDATA[<p><img src="http://o99eh3ii0.bkt.clouddn.com/17-4-22/43478794-file_1492820528872_bccd.png" alt="pic alt" title="opt title"></p>
<p>vue是前端渲染库的新宠，它只关注于view层，与传统的展现于数据分离，展现于操作分离不同。 vue推荐将操作直接绑定到视图，显得更加直观。以数据驱动的思想进行开发，将dom同步工作交给vue，开发者只需要关注数据和状态的变化，以及需要的操作。</p>
<h2 id="面向数据驱动"><a href="#面向数据驱动" class="headerlink" title="面向数据驱动"></a>面向数据驱动</h2><p>这一点，虽然看着很好理解，但在实际开发过程中，不一定能把握住精髓。我们被jQuery等dom操作的库洗脑太深了，不自觉的会往dom操作上面去想，其实vue已经做了dom操作的封装，我们真正关心的是<strong>数据的变化</strong>，一切状态的改变，ui的改变都应该是数据的变化，我们focus在数据这个点上，dom操作交给vue去处理就好, 当以这种思维去开发时，会发现以前很复杂的问题抽象到数据上来看，变得清爽，简洁了很多，一目了然。对于维护大型前端软件来说，正好切中了痛点。</p>
<h2 id="陌生中的熟悉"><a href="#陌生中的熟悉" class="headerlink" title="陌生中的熟悉"></a>陌生中的熟悉</h2><p>我们在写vue的时候是不是觉得有些写法很眼熟，对了，就是我们用了很久的模板引擎。当初的模板引擎概念局限在了模板渲染上，如今大行其道的MVVM，正是吸收了数据驱动的思想精华后的产物。它不光拥有模板引擎所有的能力，还升级了它在模块化，响应式watcher等能力。所以我们对如今纷繁的前端渲染库也不必感到那么惊慌，它们其实也是从我们熟悉的技术中演变进化而来的，MVVM就可以理解为结合了诸多前端前沿技术概念的升级版模板引擎。它就是一个增强版的view层，隐藏了dom操作，浓缩了业务逻辑到视图， 响应式通信。一切都围绕着数据驱动，让前端开发更抽象，更工程，更合理。解放了开发者的生产力。</p>
<h2 id="响应式watcher"><a href="#响应式watcher" class="headerlink" title="响应式watcher"></a>响应式watcher</h2><p>脏检查</p>
<p>es5 geter/serter</p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>refs方式：parent.$refs.list.<method><br>customer event方式: 先dispatch给父组件，再由父组件broadcast给子组件(vue1.x)<br>event bus 使用一个空的vue对象，作为全局的事件中心<br>props方式</method></p>
<h2 id="编译版本"><a href="#编译版本" class="headerlink" title="编译版本"></a>编译版本</h2><p>runtime</p>
<h2 id="vue实战"><a href="#vue实战" class="headerlink" title="vue实战"></a>vue实战</h2><h3 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h3><p>vue-cli 是vue project 的<strong>手脚架工具</strong>，官方用webpack/browserfy, 可以自定义模板, 包括eslint  karma 等完整技术栈</p>
<blockquote>
<p>Useage</p>
</blockquote>
<p><code>vue init &lt;template-name&gt; &lt;project-name&gt;</code></p>
<blockquote>
<p>默认包含这几个模板</p>
</blockquote>
<ul>
<li><p>webpack - A full-featured Webpack + vue-loader setup with hot reload, linting, testing &amp; css extraction.</p>
</li>
<li><p>webpack-simple - A simple Webpack + vue-loader setup for quick prototyping.</p>
</li>
<li><p>browserify - A full-featured Browserify + vueify setup with hot-reload, linting &amp; unit testing.</p>
</li>
<li><p>browserify-simple - A simple Browserify + vueify setup for quick prototyping.</p>
</li>
<li><p>simple - The simplest possible Vue setup in a single HTML file</p>
</li>
</ul>
<blockquote>
<p>自定义模板</p>
</blockquote>
<p><code>vue init username/repo my-project</code></p>
<h3 id="webpack入门"><a href="#webpack入门" class="headerlink" title="webpack入门"></a>webpack入门</h3><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a><a href="http://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="external">vuex</a></h3><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以<strong>相应的规则</strong>保证状态以一种可预测的方式发生变化</p>
<p>状态其实也是数据，在一个整体应用中，状态被分散了在各个组件内部，然而某些场景是需要将状态共享给其他组件，或者其他组件也需要修改同一状态。</p>
<p>vuex的解决方法是将这些状态和改变状态的行为都提出来，做一个集中式的管理, 所有组件只需要和store进行就交互就可以了。</p>
<p>对比全局的事件中心，它只提供了行为的共享，并未提供状态的共享。</p>
<p>vuex可以看成是全局变量 + 全局事件中心的结合, 同时具有响应式的能力。</p>
<blockquote>
<p>单项数据流</p>
</blockquote>
<p>多个视图依赖于同一状态。<br>来自不同视图的行为需要变更同一状态</p>
<p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p>
<blockquote>
<p>什么情况下使用vuex</p>
</blockquote>
<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。但是，如果您需要构建是一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，</p>
<p>使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。</p>
<blockquote>
<p>使用</p>
</blockquote>
<p>要使用 store ，首先必须 Vue.use(Vuex) ，然后将 store const store = new Vuex.store() inject 定义到 Vue 实例 app 中 new Vue({store}) ，实现从根组件注入到所有子组件中，接着就可以在子组件中使用 this.$store 调用了。</p>
<p>当一个组件需要使用多个某 store 的状态属性或 getters ，可以使用 shared helper —— 共享帮手 mapState ，它会返回一个对象 。</p>
<p>state可以设置计算属性</p>
<p>一条重要的原则就是要记住 mutation 必须是同步函数<br>store.commit(‘increment’)<br>// 任何由 “increment” 导致的状态变更都应该在此刻完成。</p>
<p>store是响应式的，变化后，会触发vue组件更新</p>
<h2 id="vue1-x-迁移-vue2-x"><a href="#vue1-x-迁移-vue2-x" class="headerlink" title="vue1.x 迁移 vue2.x"></a>vue1.x 迁移 vue2.x</h2><h2 id="vuex1-x-迁移-vuex2-x"><a href="#vuex1-x-迁移-vuex2-x" class="headerlink" title="vuex1.x 迁移 vuex2.x"></a>vuex1.x 迁移 vuex2.x</h2><ol>
<li>mutation的触发变成了commit</li>
<li>action可以写入到store里面</li>
<li>mapGetter，mapAction，mapMution，帮助我们映射store,getter到本地</li>
<li>action参数的改变，只有2个参数</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://segmentfault.com/a/1190000005018970" target="_blank" rel="external">vuex示例</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[2017年愿景]]></title>
      <url>http://http://localhost:4000/2017/02/13/2017-wish/</url>
      <content type="html"><![CDATA[<p>2017年愿景，写得很晚，或许是从前都没有意识到, 愿望是有的，却很模糊。今年我将它详细的写在这里，希望来年到此丰收。</p>
<h2 id="自律"><a href="#自律" class="headerlink" title="自律"></a>自律</h2><ul>
<li>早起</li>
<li>日记</li>
<li>运动</li>
<li>阅读</li>
</ul>
<h2 id="心态管理"><a href="#心态管理" class="headerlink" title="心态管理"></a>心态管理</h2><ul>
<li>情绪管理</li>
<li>哲学观完善</li>
</ul>
<h2 id="人生规划"><a href="#人生规划" class="headerlink" title="人生规划"></a>人生规划</h2><ul>
<li></li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[坑之原生对象继承]]></title>
      <url>http://http://localhost:4000/2017/01/20/array-extend/</url>
      <content type="html"><![CDATA[<h2 id="es5-继承原生对象"><a href="#es5-继承原生对象" class="headerlink" title="es5 继承原生对象"></a>es5 继承原生对象</h2><p>Boolean()<br>Number()<br>String()<br>Array()<br>Date()<br>Function()<br>RegExp()<br>Error()<br>Object()</p>
<p>在es5中，是没有办法继承原生构造函数的, 比如我们自己写一个Array</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ResponseArray</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, ArrayProto.slice.call(<span class="built_in">arguments</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line">ResponseArray.prototype = <span class="built_in">Object</span>.create(ArrayProto);</div><div class="line">ResponseArray.prototype.constructor = ResponseArray;</div></pre></td></tr></table></figure>
<p>ResponseArray 的表现与原生Array并不一致，比如length的更新</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</div><div class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</div><div class="line">colors.length  <span class="comment">// 0</span></div><div class="line"></div><div class="line">colors.length = <span class="number">0</span>; <span class="comment">// 删除元素</span></div><div class="line">colors[<span class="number">0</span>]  <span class="comment">// "red"</span></div></pre></td></tr></table></figure>
<p>原因是ES5是先新建子类的实例对象this，再将父类的属性添加到子类上,<strong>子类无法获得原生构造函数的内部属性</strong>，通过Array.apply()或者分配给原型对象都不行。<strong>原生构造函数会忽略apply方法传入的this</strong>，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</p>
<h2 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h2><p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(...args) &#123;</div><div class="line">    <span class="keyword">super</span>(...args);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MyArray();</div><div class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</div><div class="line">arr.length <span class="comment">// 1</span></div><div class="line"></div><div class="line">arr.length = <span class="number">0</span>;</div><div class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 踩过的坑 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-类型判断]]></title>
      <url>http://http://localhost:4000/2017/01/19/type-judgment/</url>
      <content type="html"><![CDATA[<h2 id="类型判断的方法"><a href="#类型判断的方法" class="headerlink" title="类型判断的方法"></a>类型判断的方法</h2><ul>
<li><code>typeof</code></li>
<li><code>instanceof</code></li>
<li><code>Object.prototype.toString</code></li>
<li><code>constructor</code></li>
</ul>
<p>各方法能力表<br><img src="http://o99eh3ii0.bkt.clouddn.com//17-1-20/75308578-file_1484882147499_9f11.png" alt=""></p>
<p><code>综合看constructor的表现最好，可以判断基本数据类型，内置对象，自定义对象。</code></p>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p><strong>typeof 是判断数据原始值的类型</strong>。<br>可能的字符串有：”number”、”string”、”boolean”、”object”、”function” 和 “undefined”。<br><strong>不支持具体的object类型</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span> == object  <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)  <span class="comment">// function</span></div></pre></td></tr></table></figure>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>判断实例与类的关系，<code>依赖constructor函数</code>。</p>
<ul>
<li>能够判别内置对象类型</li>
<li><strong>不能判别原始类型</strong></li>
<li>能够判别自定义类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//1. 能够判别内置对象类型</span></div><div class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>;<span class="comment">//true</span></div><div class="line">/\d/ <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>;<span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//2. 不能判别原始类型</span></div><div class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>;<span class="comment">//false</span></div><div class="line"><span class="string">"xiaohong"</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>;<span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="comment">//3. 能够判别自定义类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">c <span class="keyword">instanceof</span> Point;<span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//4. 局限性--依赖prototype</span></div><div class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(obj) <span class="literal">null</span> <span class="comment">//obj确凿是一个对象,但它不是任何值的实例:</span></div><div class="line"><span class="keyword">typeof</span> obj <span class="string">'object'</span></div><div class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">//false</span></div></pre></td></tr></table></figure>
<h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h2><ul>
<li>可以识别标准类型,及内置对象类型</li>
<li><strong>不能识别自定义类型</strong> <code>坑</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//1. 可以识别标准类型,及内置对象类型</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">21</span>);<span class="comment">//"[object Number]"</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call([]);<span class="comment">//"[object Array]"</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/[A-Z]/</span>);<span class="comment">//"[object RegExp]"</span></div><div class="line"></div><div class="line"><span class="comment">//2. 不能识别自定义类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">    <span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//c instanceof Point;//true</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.call(c);<span class="comment">//"[object Object]"</span></div></pre></td></tr></table></figure>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><ul>
<li>可识别原始类型</li>
<li>可识别内置对象类型</li>
<li>可识别自定义类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">//1. 可识别原始类型</span></div><div class="line"><span class="string">"guo"</span>.constructor === <span class="built_in">String</span>;<span class="comment">//true</span></div><div class="line">(<span class="number">1</span>).constructor === <span class="built_in">Number</span>;<span class="comment">//true</span></div><div class="line"><span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>;<span class="comment">//true</span></div><div class="line">(&#123;&#125;).constructor === <span class="built_in">Object</span>;<span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//2. 可识别内置对象类型</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor === <span class="built_in">Date</span>;<span class="comment">//true</span></div><div class="line">[].constructor === <span class="built_in">Array</span>;<span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="comment">//3. 可识别自定义类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.x = x;</div><div class="line">	<span class="keyword">this</span>.y = y;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> People(<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">c.constructor===People;<span class="comment">//true</span></div></pre></td></tr></table></figure>
<h2 id="常用封装"><a href="#常用封装" class="headerlink" title="常用封装"></a>常用封装</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//判断类型--toString</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeProto</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//判断类型--constructor</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getConstructorName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor.toString().match(<span class="regexp">/function\s*([^(]*)/</span>)[<span class="number">1</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//变量是否定义(不等于null，也不等于undefined)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDefined</span>(<span class="params">x</span>) </span>&#123; </div><div class="line">	<span class="keyword">return</span> x !== <span class="literal">null</span> &amp;&amp; x !== <span class="literal">undefined</span>; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//检测x是否是一个对象值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">x</span>) </span>&#123; </div><div class="line">	<span class="keyword">return</span> (<span class="keyword">typeof</span> x === <span class="string">"function"</span> || (<span class="keyword">typeof</span> x === <span class="string">"object"</span> &amp;&amp; x !== <span class="literal">null</span>)); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript-类型转换]]></title>
      <url>http://http://localhost:4000/2017/01/18/mplicit-type-conversion/</url>
      <content type="html"><![CDATA[<p>JavaScript，不同数据类型在不同运算符下会做不同的类型转换，这是坑点之一也是面试经常考的一个问题。</p>
<h2 id="valueOf与toString方法"><a href="#valueOf与toString方法" class="headerlink" title="valueOf与toString方法"></a>valueOf与toString方法</h2><p>要理解在类型转换的时候底层做了什么事情，就不得不说valueOf与toString方法了。<br><strong>valueOf的意思是返回最适合该对象类型的原始值，而toString则是将在该对象类型的原始值以字符串形式返回。</strong></p>
<blockquote>
<p>valueOf</p>
</blockquote>
<table>
<thead>
<tr>
<th>对象</th>
<th style="text-align:left">返回值p</th>
</tr>
</thead>
<tbody>
<tr>
<td>对象</td>
<td style="text-align:left">返回值</td>
</tr>
<tr>
<td>Array</td>
<td style="text-align:left">数组实例对象</td>
</tr>
<tr>
<td>Boolean</td>
<td style="text-align:left">布尔值</td>
</tr>
<tr>
<td>Date</td>
<td style="text-align:left">以毫秒数存储的时间值，从 UTC 1970 年 1 月 1 日午夜开始计算</td>
</tr>
<tr>
<td>Function</td>
<td style="text-align:left">函数本身</td>
</tr>
<tr>
<td>Number</td>
<td style="text-align:left">数字值</td>
</tr>
<tr>
<td>Object</td>
<td style="text-align:left">对象本身。这是默认设置</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">字符串值</td>
</tr>
</tbody>
</table>
<blockquote>
<p>toString</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left">行为描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Array</td>
<td style="text-align:left"><strong>将 Array 的每个元素转换为字符串，并将它们依次连接起来，两个元素之间用英文逗号作为分隔符进行拼接。</strong></td>
</tr>
<tr>
<td>Boolean</td>
<td style="text-align:left">如果布尔值是true，则返回”true”。否则返回”false”。</td>
</tr>
<tr>
<td>Date</td>
<td style="text-align:left">返回日期的文本表示。</td>
</tr>
<tr>
<td>Error</td>
<td style="text-align:left">返回一个包含相关错误信息的字符串。</td>
</tr>
<tr>
<td>Function</td>
<td style="text-align:left"><strong>返回如下格式的字符串，其中 functionname 是一个函数的名称，此函数的 toString 方法被调用： “function functionname() { [native code] }” </strong></td>
</tr>
<tr>
<td>Number</td>
<td style="text-align:left">返回数值的字符串表示。还可返回以指定进制表示的字符串，请参考Number.toString()。</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:left">返回 String 对象的值。</td>
</tr>
<tr>
<td>Object(默认)</td>
<td style="text-align:left">返回”[object ObjectName]”，其中 ObjectName 是对象类型的名称。</td>
</tr>
</tbody>
</table>
<h2 id="隐式类型转换规则"><a href="#隐式类型转换规则" class="headerlink" title="隐式类型转换规则"></a><a href="http://www.cnblogs.com/wangmeijian/p/4639112.html" target="_blank" rel="external">隐式类型转换规则</a></h2><p><img src="http://o99eh3ii0.bkt.clouddn.com//17-1-19/91445201-file_1484798327287_1767e.png" alt="pic alt" title="opt title"></p>
<p>原始值的转换就是原始值，<strong>主要要关注的是复合对象转原始值</strong>。会先调用valueOf(),如果返回值不是原始值，再调用toString，再转成对应的类型</p>
<blockquote>
<p><code>+</code></p>
</blockquote>
<ol>
<li>如果其中一个操作数是对象，对象会转换成原始值：日期对象通过toString()方法转换，其他对象通过valueOf()方法转换，如果valueOf()返回值不是原始值再使用toString()方法转换。</li>
<li>在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另一个操作数也会转换为字符串，然后进行字符串拼接。</li>
<li>否则，两个操作数都将转换为数字（转换不了的将转换为NaN），然后进行加法操作。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="number">1</span> + <span class="literal">true</span>       <span class="comment">// true转换为1,然后加法得出结果2</span></div><div class="line"><span class="string">"1"</span> + <span class="literal">true</span>     <span class="comment">// true转换为"true"，然后字符串拼接得出结果"1true"</span></div><div class="line"><span class="number">1</span> + <span class="string">"1"</span>        <span class="comment">// 数字1转换为"1"，然后字符串拼接得出结果"11"</span></div><div class="line">&#123;&#125; + <span class="number">1</span>         <span class="comment">// &#123;&#125;对象调用toString()方法转换为字符串"[object Object]"，变成了"[object Object]" + 1，匹配第二条规则，1将转换为字符串"1"，然后字符串拼接得出结果"[object Object]1"</span></div><div class="line">&#123;&#125; + &#123;&#125;        <span class="comment">// 自己想想过程吧</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>- * / ==</code></p>
</blockquote>
<p>会把左右两边转成数字，转不了的转成NaN, 复合类型会先调用valueOf -&gt; toString -&gt; number</p>
<h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a><a href="http://www.cnblogs.com/onepixel/p/5281796.html" target="_blank" rel="external">NaN</a></h2><p>它是number类型的一个特殊状态,不是一个确定的值。 typeof NaN == number</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>    <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>所以它自己不等于自己。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[坑之箭头函数]]></title>
      <url>http://http://localhost:4000/2017/01/18/es6-arrow-function/</url>
      <content type="html"><![CDATA[<h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误, 因为没有this<br>（3）不可以使用arguments,caller对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。<br>（4）不可用于prototype的method<br>（5）不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
<p>this,arguments,caller都没有，都是继承父function作用域的。</p>
<p>使用场景为优化回调，拉平层次。</p>
]]></content>
      
        <categories>
            
            <category> 踩过的坑 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[es6调研报告]]></title>
      <url>http://http://localhost:4000/2016/12/29/es6/</url>
      <content type="html"><![CDATA[<p>es6(ECMAScript 6) 下一代JavaScript标准语法,它是JavaScript的血统重构，也是前端混乱丛生的语法糖规范的大一统。或许某一天我们就不再需要各种<code>弥补</code>js缺陷的框架，js已经足够强大去处理各种问题。这一天应该不远了。我们需要重新认识JavaScript，就从es6开始。</p>
<p>目前主流的项目都用es6来做了，这是趋势，个人认为其中一个比较重要的内因是，js能做的事情越来越强，需求越来越多，语言能力必须得跟上。构建大型js软件需要言语层面的支持。随着es6的普及，很多辅助的类库都会被弃用了，js会更加成熟。</p>
<p>我是看了vue2.0的项目后，决定好好学习下es6，受限于公司技术栈，之前并没有使用过，有种es6还很遥远的错觉, 其实它已经泛滥了！我更被敲响了一个警钟，多看看当前最火的技术项目，你才不会掉队。</p>
<h2 id="es6目前的整体情况"><a href="#es6目前的整体情况" class="headerlink" title="es6目前的整体情况"></a>es6目前的整体情况</h2><table>
<thead>
<tr>
<th>平台</th>
<th style="text-align:left">支持情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>Androia</td>
<td style="text-align:left">差得远</td>
</tr>
<tr>
<td>ios 10</td>
<td style="text-align:left">100%支持</td>
</tr>
<tr>
<td>ios 9</td>
<td style="text-align:left">50%支持</td>
</tr>
<tr>
<td>chrome，Safari，Edge，Firefox，Opera</td>
<td style="text-align:left">差不多97%</td>
</tr>
<tr>
<td>nodejs，6.5  以上</td>
<td style="text-align:left">差不多支持了97%的新特性。</td>
</tr>
</tbody>
</table>
<p><strong>总体看Safari是对es6支持最好的浏览器,支持率100%。</strong><br><strong>其中支持module特性的只有Safari Technology Preview 21 及其以上和Edge最新版，nodejs 6也不支持import，只能用require。</strong></p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//17-2-5/33253591-file_1486288762048_15985.png" alt="pic alt" title="opt title"></p>
<p>详细的支持情况可以参考这个表 <a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external">es6各平台兼容表</a></p>
<h2 id="es6书写环境"><a href="#es6书写环境" class="headerlink" title="es6书写环境"></a>es6书写环境</h2><p>写es6的方法有很多，最终我选择 rollup + babel + eslint。最核心的考虑点是基于es6的module系统和class, 这2个特性是构建复杂，大型js应用的关键所在。 我们能做的是尽可能的贴近标准规范。没用webpack除了个原因外，还因为rollup可以只打包用到的函数，方法。</p>
<p>浏览器端大多数特性都不支持，所以还是需要babel这样的转换器转换成es5的代码。</p>
<p>构建一个项目的底层并不容易，要考虑项目的实际情况，目录结构规范，代码规范，构建流程。rollup比较适合写js库，如果是写应用页面，那么就不合适，还需要考虑到项目的seo优化,rollup没有这方面的能力，需要结合其他的构建工具。</p>
<h2 id="rollup-cli"><a href="#rollup-cli" class="headerlink" title="rollup cli"></a>rollup cli</h2><p>需要重新学习一套rollup的配置流，上手快(当然得看个人), 坑少，官方构建工具。当需要输出多个版本,或者其他自定义构建的时候，显得不那么灵活。</p>
<h2 id="gulp-better-rollup"><a href="#gulp-better-rollup" class="headerlink" title="gulp-better-rollup"></a>gulp-better-rollup</h2><p>基于rollup js API的封装，使之与gulp的工作流结合，与上一个的区别是，gulp的社区广泛，大多数人最熟的，有人写插件。上手快，但是有很多隐藏的坑，这不排第一的gulp-rollup就挺坑的，有很多重叠的配置。因为已经是二次封装了。熟悉npm的API的同时，为了避免坑还要了解rollup 自己的底层API。好在社区广泛，大多数工具可以重复利用，有积累价值。</p>
<p>babel插件要使用rollup自己的，需要在单文件的时候就进行转换。其他的比如sourcemap, replace等可以用gulp的工具流, 此babel插件的配置可以集成到rollup的配置里面，不需要另外写一个配置文件。</p>
<p>多版本输出，可以输出不同format的bundle，如果是不同工作流，就再写一个task吧，最开始我还想抽象一下成为配置文件，后来发现其实没必要，gulp的api已经是可以配置+简易编程的了，一个task其实就是一个配置文件，也不在乎多写那几行代码，拷贝就行，就是对强迫症有点难受(卧槽。。我真的是强迫症。。)。</p>
<h2 id="rollup-js-API"><a href="#rollup-js-API" class="headerlink" title="rollup js API"></a>rollup js API</h2><p>最底层的API，最灵活，坑少。同时成本也很高。如果不用gulp，就需要自己实现流程控制.</p>
<p>总的来看 js API是效果最好的，当然要求也高, 必须要对这个东西有谱，查问题的时候还是得看1手资料。其次还是建议使用gulp-rollup, 这肯定是大多数人使用的版本，对行情的了解是有帮助的, 初看可能受益没那么高，但是是有积累价值的。</p>
<h2 id="yeomen-工程包"><a href="#yeomen-工程包" class="headerlink" title="yeomen 工程包"></a>yeomen 工程包</h2><p>写了一个npm包，集成了es6 + rollup + gulp + eslint. 基本构成es6书写环境。 欢迎下载试用</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">## 依赖就全局安装吧，反正后续也会用</div><div class="line">npm install -g yeoman-generator</div><div class="line">npm install -g babel</div><div class="line">npm install-g babel-cli</div><div class="line">npm install -g rollup</div><div class="line"></div><div class="line">npm install -g generator-baseconfig</div><div class="line"></div><div class="line">## 生成</div><div class="line">yo baseconfig</div></pre></td></tr></table></figure>
<h2 id="es6教程"><a href="#es6教程" class="headerlink" title="es6教程"></a>es6教程</h2><p>我并没有刻意的去学es6，不过是找以前的写的代码，然后看一个es6特性，就套一个特性。帮助我加深印象，也更加实际的体会新语法的特点是什么。<br>语法可以参考 阮一峰大神的。 <a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>年底了，拖了好久才开始写这篇文章，去年定得目标是赶上前端技术潮流，稀里糊涂的折腾了一年，前端技术进步得也不多啊。。。到是一天发神经折腾编辑器(你确定不是本末倒置？)。哈哈，随便吧，想到哪儿就写到哪儿吧。想2017许个愿，玛德我还真没什么愿望。就身体健康，万事如意吧。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[日志统计-设计]]></title>
      <url>http://http://localhost:4000/2016/12/22/log-design/</url>
      <content type="html"><![CDATA[<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-12-22/73583930-file_1482380508428_68d4.png" alt="Alt Text"> </p>
<p>日志稳定性乃重中之重，是所有日志运用的基石。<br>攘外必先安内！</p>
<p>日志是个历史问题尤为严重的领域，特别是大公司，轻易不敢动规范, 只做加法，不做减法。如果稳定性差了，长此以往，必然无法维护，怨声载道。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><ol>
<li>日志其实还是挺被动的。一般来说是先有产品，再有日志方案。及其依赖基础架构的扩展性。</li>
<li>统计在某些情况下会影响整体的体验和性能，中间该如何权衡是个问题, 切忌本末倒置。</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[tmux + Tmuxinator  打造你的炫酷终端分屏环境]]></title>
      <url>http://http://localhost:4000/2016/12/20/code-workflow/</url>
      <content type="html"><![CDATA[<h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>tmux 是一个终端分屏软件，你是否还在感叹终端窗口不够用? 有了它，你就可以不用操心了。并且可以运行在服务端，就算ssh链接断开了也没事，下次登录，在链接上会话就可以继续前面的进度工作了。<br>对于拥有大屏的你简直爽到爆啊!</p>
<p><img src="https://camo.githubusercontent.com/9b914113e5e2377e9d7fa93112c0639f398bb8ba/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f3134313231332f3931363038342f30363566656637632d666538322d313165322d396332332d6139363232633764383363332e706e67" alt="Alt Text"> </p>
<blockquote>
<p>配置文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tmux source-file ~/.tmux.conf</div></pre></td></tr></table></figure>
<blockquote>
<p>基本快捷键</p>
</blockquote>
<ul>
<li>tmux new -s work   新建会话</li>
<li>tmux ls 显示当前已经创建的会话</li>
<li>tmux a -t name 链接会话</li>
<li>tmux kill-session -t work 关闭指定 session</li>
<li><p>tmux kill-server 关闭所有 session</p>
</li>
<li><p>c+b l 最近使用的window</p>
</li>
<li>c+b ; 最近使用的panel</li>
<li>c+b “ 横向分割窗口，创建 pane</li>
<li>c+b 方向键  切换pane</li>
<li>c+b , 重命名window</li>
<li>c+b c 新建window</li>
<li>c+b ? 查看按键绑定</li>
<li>c+b Q 关闭window</li>
<li>c+b z toggle最大化pane</li>
<li>c+b d 退出并保存会话</li>
<li>c+b s 切换会话</li>
</ul>
<blockquote>
<p>复制到系统剪切板</p>
</blockquote>
<p>如果你用item2，需要开启mouse report</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-12-21/35255665-file_1482308304418_115b9.png" alt="Alt Text"> </p>
<blockquote>
<p>&lt;=2.0 配置示例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">setw -g mode-mouse on</div><div class="line">set -g mouse-select-pane on</div><div class="line"></div><div class="line"> #setw -g mode-keys vi</div><div class="line"></div><div class="line"> #关闭自动命名</div><div class="line"> set-option -g allow-rename off</div><div class="line"></div><div class="line"> #分屏操作</div><div class="line"> bind | split-window -h</div><div class="line"> bind - split-window -v</div><div class="line"></div><div class="line"> #设置终端颜色</div><div class="line"> set -g default-terminal &quot;screen-256color&quot;</div><div class="line"> set -g default-terminal &quot;screen-256color-bce&quot;</div><div class="line"> #设置esc延迟</div><div class="line"> set -sg escape-time 10</div><div class="line"></div><div class="line"> #旋转pane</div><div class="line"> bind r rotate-window</div><div class="line"> bind q break-pane</div><div class="line"> bind Q kill-window</div></pre></td></tr></table></figure>
<blockquote>
<p>2.0 及其以上配置示例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">set -g mouse on</div><div class="line">#setw -g mode-keys vi  </div><div class="line"></div><div class="line">#关闭自动命名</div><div class="line">set-option -g allow-rename off</div><div class="line"></div><div class="line">#分屏操作</div><div class="line">bind | split-window -h</div><div class="line">bind - split-window -v</div><div class="line"></div><div class="line">#设置终端颜色</div><div class="line">set -g default-terminal &quot;screen-256color&quot;</div><div class="line">set -g default-terminal &quot;screen-256color-bce&quot;</div><div class="line">#设置esc延迟</div><div class="line">set -sg escape-time 10</div><div class="line"></div><div class="line">#旋转pane</div><div class="line">bind r rotate-window</div><div class="line">bind q break-pane</div><div class="line">bind Q kill-window</div><div class="line"></div><div class="line"></div><div class="line">#光标shape</div><div class="line">set -g -a terminal-overrides &apos;,*:Ss=\E[%p1%d q:Se=\E[2 q&apos;</div><div class="line"></div><div class="line">#鼠标滚屏</div><div class="line">bind -n WheelUpPane if-shell -F -t = &quot;#&#123;mouse_any_flag&#125;&quot; &quot;send-keys -M&quot; &quot;if -Ft= &apos;#&#123;pane_in_mode&#125;&apos; &apos;send-keys -M&apos; &apos;select-pane -t=; copy-mode -e; send-keys -M&apos;&quot;  </div><div class="line">bind -n WheelDownPane select-pane -t= \; send-keys -M</div></pre></td></tr></table></figure>
<blockquote>
<p>命令行模式</p>
</blockquote>
<p>类似 vim，输入:后，进入命令模式，可以完成大部分操作 如<code>source-file ~/.tmux.conf</code></p>
<h2 id="tmuxinator"><a href="#tmuxinator" class="headerlink" title="tmuxinator"></a>tmuxinator</h2><p>可以快速创建 tmux 的窗口分布, 管理 tmux 的会话</p>
<blockquote>
<p>安装</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gem install tmuxinator</div><div class="line"></div><div class="line"># 写到 bashrc 或者 zshrc 里面，设置默认编辑器</div><div class="line">export EDITOR=&apos;vim&apos;</div></pre></td></tr></table></figure>
<blockquote>
<p>基本快捷键</p>
</blockquote>
<p>其实这些操作都是编辑的.tmuxinator/ 下的配置文件，可以直接修改</p>
<ul>
<li>tmuxinator n work    创建工程配置</li>
<li>tmuxinator o work    打开指定配置文件</li>
</ul>
<blockquote>
<p>基本配置语法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># o 命令打开时的工程名称</div><div class="line">name: sample</div><div class="line"># 所有命令的根目录</div><div class="line">root: ~/</div><div class="line"># 窗口设置</div><div class="line">windows:</div><div class="line">  - editor:</div><div class="line">      layout: main-vertical</div><div class="line">      panes:</div><div class="line">        - vim</div><div class="line">        - guard</div><div class="line">  - server: bundle exec rails s</div><div class="line">  - logs: tail -f log/development.log</div></pre></td></tr></table></figure>
<blockquote>
<p>自定义窗口布局</p>
</blockquote>
<p>默认有几种 layout, 开启tmux后，可以使用快捷键prefix space切换layout，建议开启4个Pane进行测试。</p>
<ul>
<li>even-horizontal</li>
<li>even-vertical</li>
<li>main-horizontal</li>
<li>main-vertical</li>
<li>tiled</li>
</ul>
<p>自定义 layout 步骤:</p>
<ul>
<li>在 tmux 中调整好窗口的位置信息，执行<code>tmux list-windows</code>，会出现位置信息参数。</li>
<li>将其拷贝到配置文件的 layout 参数，<code>注意去掉前面那节</code></li>
</ul>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-12-21/32534178-file_1482309129558_2186.png" alt="Alt Text"> </p>
<blockquote>
<p> 一个 pane 执行多个命令</p>
</blockquote>
<p>可以用&amp;&amp; 符号链接命令,或者如下</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-12-21/23997236-file_1482309214236_c2e6.png" alt="Alt Text"> </p>
]]></content>
      
        <categories>
            
            <category> vim </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[http--thunk 和 Bigpipe]]></title>
      <url>http://http://localhost:4000/2016/12/07/http-thunk/</url>
      <content type="html"><![CDATA[<h2 id="content-length"><a href="#content-length" class="headerlink" title="content-length"></a>content-length</h2><p>content-length是消息传输实体的传输长度,在HTTP/1.0下，content-length可有可无。因为通过服务器端关闭连接可以确定消息的传输长度，谓之短连接，即非keep-live模式</p>
<h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><p>在HTTP/1.1下，如果设置了transfer-Encoding，说明消息长度和消息传输长度不等，此时不能设置content-length，有也会被忽视。如果没有设置transfer-Encoding，那么情况就和HTTP1.0一样，可以是非Keep-live模式，也可以设置Content-length。顾名思义,Transfer-Encoding下Chunk模式是在HTTP/1.1才有的模式，即分块传输。</p>
<h2 id="为什么会有chunk模式"><a href="#为什么会有chunk模式" class="headerlink" title="为什么会有chunk模式"></a>为什么会有chunk模式</h2><p>如果服务器准备发送的内容需要动态创建，那么在创建完成之前，消息大小都是未知的，那么消息头就无法生成，content-length无法计算。而Chunk模式允许消息头在传输完成之发送，这就可以在消息大小生成前发送消息内容。如果没有这种模式，会造成浏览器端迟迟收不到响应，因为服务器处于动态创建内容的缓冲状态。</p>
<h2 id="gzip-chunk"><a href="#gzip-chunk" class="headerlink" title="gzip + chunk"></a>gzip + chunk</h2><p>如果消息通过gzip压缩的话，那么就可以压缩与传输并行，也就是说，压缩一块消息，传输一块一块消息，边压缩，边传输，这样可以提高传输效率。</p>
<h2 id="chunk-格式"><a href="#chunk-格式" class="headerlink" title="chunk 格式"></a>chunk 格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Chunked-Body   = *chunk  </div><div class="line">                 last-chunk  </div><div class="line">                 trailer  </div><div class="line">                 CRLF  </div><div class="line">  </div><div class="line">chunk          = chunk-size [ chunk-extension ] CRLF  </div><div class="line">                 chunk-data CRLF  </div><div class="line">chunk-size     = 1*HEX  </div><div class="line">last-chunk     = 1*(&quot;0&quot;) [ chunk-extension ] CRLF  </div><div class="line">  </div><div class="line">chunk-extension= *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )  </div><div class="line">chunk-ext-name = token  </div><div class="line">chunk-ext-val  = token | quoted-string  </div><div class="line">chunk-data     = chunk-size(OCTET)  </div><div class="line">trailer        = *(entity-header CRLF)</div></pre></td></tr></table></figure>
<p>格式如上， 简单说明一下，主要有三个大部分：</p>
<p>首先，Chunk每一个非空的部分有俩个部分组成：</p>
<ol>
<li>chunk-size及其长度单位 </li>
<li>chunk-data</li>
</ol>
<p><strong>其次，Chunk串的最后一块是一个长度为0的块（last-chunk）</strong><br>最后，Chunk最后一块的后面跟着一个可选的尾部trail（包括消息头header）<br>CRLF是指回车换行</p>
<h2 id="BigPipe"><a href="#BigPipe" class="headerlink" title="BigPipe"></a>BigPipe</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/b2997215859/article/details/51169784" target="_blank" rel="external">chunk编码</a></p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[网络协议]]></title>
      <url>http://http://localhost:4000/2016/12/05/network/</url>
      <content type="html"><![CDATA[<h2 id="四层架构"><a href="#四层架构" class="headerlink" title="四层架构"></a>四层架构</h2><p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-12-5/62257832.jpg" alt="Alt Text"><br><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-12-5/73373789.jpg" alt="Alt Text"> </p>
<h2 id="TCP-IP-三次握手"><a href="#TCP-IP-三次握手" class="headerlink" title="TCP/IP 三次握手"></a>TCP/IP 三次握手</h2><p>TCP/IP协议，通过三次握手建立可靠连接<br><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-12-5/64708406.jpg" alt="Alt Text"> </p>
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p>socket又叫套接字,它是TCP/IP协议的编程接口API。</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-12-5/16665016.jpg" alt="Alt Text"> </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://my.oschina.net/githubhty/blog/649034" target="_blank" rel="external">数据传输协议</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[nodejs 入门]]></title>
      <url>http://http://localhost:4000/2016/12/03/nodejs-env/</url>
      <content type="html"><![CDATA[<p>js 可以写前端，服务端，游戏，脚本，桌面应用(linux,mac,windows),能力相当全面了。学了还是比较保值的。<br>nodejs很火，很牛叉，迭代非常迅速，现在都8.0了(我的天…) 。 为了不让自己累死，所以学着积累。能力比知识重要，掌握能力才是关键。</p>
<h2 id="文档教程"><a href="#文档教程" class="headerlink" title="文档教程"></a>文档教程</h2><p>看<a href="https://nodejs.org/api/debugger.html#debugger_information" target="_blank" rel="external">官方文档</a>是最好的。授人以鱼不如授人以渔，借用张孝祥的一句话，要学会看一手资料, 别看二手资料。</p>
<p>有mac的同学推荐使用Dash，包含各种软件，语言的文档。绝对神器。</p>
<p>新手教程就看看这篇吧<a href="http://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="external">教程</a> (哎。。又给人家导流了..)</p>
<h2 id="编写环境与调试"><a href="#编写环境与调试" class="headerlink" title="编写环境与调试"></a>编写环境与调试</h2><p>文本编辑器 : 推荐(ST , vim , emacs, vscode)<br>IDE        : 推荐webstorm</p>
<h3 id="hot-node"><a href="#hot-node" class="headerlink" title="hot-node"></a>hot-node</h3><p><code>npm install -g hotnode</code><br><code>hotnode index.js</code><br>当你修改程序后，会自动重新运行, 程序报错时，不会挂掉(写web程序时非常有用)</p>
<h3 id="repl-交互式命令debug"><a href="#repl-交互式命令debug" class="headerlink" title="repl-交互式命令debug"></a>repl-交互式命令debug</h3><p>在代码中需要打断点的地方写上debugger, 也可以在debug模式运行起来后再设置断点。</p>
<h4 id="演示调试流程"><a href="#演示调试流程" class="headerlink" title="演示调试流程:"></a>演示调试流程:</h4><p><code>node debug index.js</code> // run</p>
<p><code>help</code> // to see the action you can do</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-12-31/9802197-file_1483181608362_9ad3.png" alt="Alt Text"> </p>
<p><code>list(100)</code>// 查看前后100行代码</p>
<p><code>sb(112)</code> // 浏览代码，在需要设置断点的地方设置断点</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-12-31/30114647-file_1483181750934_702.png" alt="Alt Text"> </p>
<p><code>c</code>  // 跳跃到最近的断点</p>
<p><code>s</code>  // step run</p>
<p><code>n</code>  // line run</p>
<p><code>o</code>  // out the function</p>
<p><code>repl</code>  // 进入交互计算模式, 类似chrome的console，直接输入变量即可查看值</p>
<p><code>ctrl + c</code>  // 退出repl</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-12-31/12879852-file_1483181933556_141dd.png" alt="Alt Text"> </p>
<h4 id="操作解释"><a href="#操作解释" class="headerlink" title="操作解释"></a>操作解释</h4><table>
<thead>
<tr>
<th>name</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>run</td>
<td style="text-align:left">执行脚本,在第一行暂停</td>
</tr>
<tr>
<td>restart</td>
<td style="text-align:left">重新执行脚本</td>
</tr>
<tr>
<td>cont, c</td>
<td style="text-align:left">继续执行,直到遇到下一个断点</td>
</tr>
<tr>
<td>next, n</td>
<td style="text-align:left">单步执行</td>
</tr>
<tr>
<td>step, s</td>
<td style="text-align:left">单步执行并进入函数</td>
</tr>
<tr>
<td>out, o</td>
<td style="text-align:left">从函数中步出</td>
</tr>
<tr>
<td>setBreakpoint(), sb()</td>
<td style="text-align:left">当前行设置断点</td>
</tr>
<tr>
<td>setBreakpoint(‘f()’), sb(…)</td>
<td style="text-align:left">在函数f的第一行设置断点</td>
</tr>
<tr>
<td>setBreakpoint(‘script.js’, 20), sb(…)</td>
<td style="text-align:left">在 script.js 的第20行设置断点</td>
</tr>
<tr>
<td>clearBreakpoint, cb(…)</td>
<td style="text-align:left">清除所有断点</td>
</tr>
<tr>
<td>backtrace, bt</td>
<td style="text-align:left">显示当前的调用栈</td>
</tr>
<tr>
<td>list(5)</td>
<td style="text-align:left">显示当前执行到的前后5行代码</td>
</tr>
<tr>
<td>watch(expr)</td>
<td style="text-align:left">把表达式 expr 加入监视列表</td>
</tr>
<tr>
<td>unwatch(expr)</td>
<td style="text-align:left">把表达式 expr 从监视列表移除</td>
</tr>
<tr>
<td>watchers</td>
<td style="text-align:left">显示监视列表中所有的表达式和值</td>
</tr>
<tr>
<td>repl</td>
<td style="text-align:left">在当前上下文打开即时求值环境</td>
</tr>
<tr>
<td>kill</td>
<td style="text-align:left">终止当前执行的脚本</td>
</tr>
<tr>
<td>scripts</td>
<td style="text-align:left">显示当前已加载的所有脚本</td>
</tr>
<tr>
<td>version</td>
<td style="text-align:left">显示v8版本</td>
</tr>
</tbody>
</table>
<h3 id="v8-and-chrome-DevTool"><a href="#v8-and-chrome-DevTool" class="headerlink" title="v8 and chrome DevTool"></a>v8 and chrome DevTool</h3><p>v8可以支持远程调试, 有诸如node-inspector之类的工具，可以在chrome DevTool中调试。不过我将nodejs升级到6以后，使用node-inspector 报错了。后来翻了下文档，发现node自带工具可以直接chrome 调试打通</p>
<p><code>node --debug-brk  --inspect build/build.js</code></p>
<p>在chrome中打开生成的链接就可以了，与chrome调试无异。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nodejs.org/api/debugger.html#debugger_information" target="_blank" rel="external">nodejs documentiton</a></p>
]]></content>
      
        <categories>
            
            <category> nodejs </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[nodejs--deepCopy]]></title>
      <url>http://http://localhost:4000/2016/12/02/node-deep-copy/</url>
      <content type="html"><![CDATA[<p>原以为 nodejs对es6的支持很好了，会有这个方法。结果发现nodejs不支持深度拷贝</p>
<p>Object.assign(target,source,source), 只是浅拷贝。</p>
<h2 id="自实现深拷贝"><a href="#自实现深拷贝" class="headerlink" title="自实现深拷贝"></a>自实现深拷贝</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 继承对象方法</div><div class="line">*</div><div class="line">* @param parent 继承者</div><div class="line">* @param child  被继承者</div><div class="line">* @param isDeep 是否深度拷贝</div><div class="line">* @isMerge 数组合并,注意值没有去重</div><div class="line">* @returns number 失败返回-1</div><div class="line">*/ </div><div class="line"><span class="function"><span class="keyword">function</span>  <span class="title">extend</span>(<span class="params">parent, child, isDeep, isMerge</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> ( <span class="keyword">typeof</span> parent !== <span class="string">'object'</span> || <span class="keyword">typeof</span> child !== <span class="string">'object'</span>) &#123;</div><div class="line">	    <span class="keyword">return</span>  parent;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (isDeep) &#123;</div><div class="line">	    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> child) &#123;</div><div class="line">		<span class="keyword">if</span> (child.hasOwnProperty(i)) &#123;</div><div class="line">		    <span class="keyword">if</span> ( <span class="keyword">typeof</span> child[i] === <span class="string">'object'</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (isMerge &amp;&amp; <span class="built_in">Array</span>.isArray(child[i]) &amp;&amp; <span class="built_in">Array</span>.isArray(parent[i]) ) &#123;</div><div class="line">			    <span class="keyword">var</span> p1 = <span class="keyword">this</span>.extend([], parent[i], isDeep);</div><div class="line">			    <span class="keyword">var</span> c1 = <span class="keyword">this</span>.extend([], child[i], isDeep);</div><div class="line">			    parent[i] = p1.concat(c1);</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">			    parent[i] = <span class="built_in">arguments</span>.callee(&#123;&#125;, child[i], isDeep);</div><div class="line">			&#125;</div><div class="line">		    &#125;<span class="keyword">else</span>&#123;</div><div class="line">			parent[i] = child[i];</div><div class="line">		    &#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">	    <span class="keyword">for</span> (<span class="keyword">var</span> j <span class="keyword">in</span> child) &#123;</div><div class="line">		<span class="keyword">if</span> (child.hasOwnProperty(j)) &#123;</div><div class="line">		    parent[j] = child[j];</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以支持深浅拷贝，可以支持数组merge</p>
]]></content>
      
        <categories>
            
            <category> 踩过的坑 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[awk 简单入门]]></title>
      <url>http://http://localhost:4000/2016/11/30/awk/</url>
      <content type="html"><![CDATA[<p>awk是一个强大的文本处理工具，在处理简单的文本数据时非常有用，甚至在写mapreduce的时候也能派上用场。它是按行处理文本的, 可以与sed，grep结合</p>
<h2 id="指定分隔符"><a href="#指定分隔符" class="headerlink" title="指定分隔符"></a>指定分隔符</h2><p>默认是按\t制表符分割</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">awk -F, &apos;&#123;print $1,$2&#125;&apos;   log.txt</div><div class="line"></div><div class="line"># 或者使用内建变量</div><div class="line">awk &apos;BEGIN&#123;FS=&quot;,&quot;&#125; &#123;print $1,$2&#125;&apos;     log.txt</div><div class="line"></div><div class="line"># 使用多个分隔符.先使用空格分割，然后对分割结果再使用&quot;,&quot;分割</div><div class="line">awk -F &apos;[ ,]&apos;  &apos;&#123;print $1,$2,$5&#125;&apos;   log.txt</div></pre></td></tr></table></figure>
<h2 id="按行过滤"><a href="#按行过滤" class="headerlink" title="按行过滤"></a>按行过滤</h2><figure class="highlight awk"><table><tr><td class="code"><pre><div class="line"></div><div class="line">awk <span class="string">'[pattern] &#123;action&#125;'</span> &#123;filenames&#125;   <span class="comment"># 行匹配语句 awk '' 只能用单引号</span></div><div class="line"></div><div class="line">awk <span class="string">'$1==2 &#123;print $1,$3&#125;'</span> log.txt    <span class="comment">#命令</span></div></pre></td></tr></table></figure>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><ul>
<li>BEGIN{ 这里面放的是执行前的语句 }</li>
<li>END {这里面放的是处理完所有的行后要执行的语句 }</li>
<li>{这里面放的是处理每一行时要执行的语句}</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">awk '</div><div class="line">#运行前</div><div class="line">BEGIN &#123;</div><div class="line">    math = 0</div><div class="line">    english = 0</div><div class="line">    computer = 0</div><div class="line"> </div><div class="line">    printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"</div><div class="line">    printf "---------------------------------------------\n"</div><div class="line">&#125;</div><div class="line">#运行中</div><div class="line">&#123;</div><div class="line">    math+=$3</div><div class="line">    english+=$4</div><div class="line">    computer+=$5</div><div class="line">    printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5</div><div class="line">&#125;</div><div class="line">#运行后</div><div class="line">END &#123;</div><div class="line">    printf "---------------------------------------------\n"</div><div class="line">    printf "  TOTAL:%10d %8d %8d \n", math, english, computer</div><div class="line">    printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR</div><div class="line">&#125;' test.txt</div></pre></td></tr></table></figure>
<h2 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h2><table>
<thead>
<tr>
<th>name</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>$n</td>
<td style="text-align:left">当前记录的第n个字段，字段间由FS分隔</td>
</tr>
<tr>
<td>$0</td>
<td style="text-align:left">完整的输入记录</td>
</tr>
<tr>
<td>ARGC</td>
<td style="text-align:left">命令行参数的数目</td>
</tr>
<tr>
<td>ARGIND</td>
<td style="text-align:left">命令行中当前文件的位置(从0开始算)</td>
</tr>
<tr>
<td>ARGV</td>
<td style="text-align:left">包含命令行参数的数组</td>
</tr>
<tr>
<td>CONVFMT</td>
<td style="text-align:left">数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td>
</tr>
<tr>
<td>ERRNO</td>
<td style="text-align:left">最后一个系统错误的描述</td>
</tr>
<tr>
<td>FIELDWIDTHS</td>
<td style="text-align:left">字段宽度列表(用空格键分隔)</td>
</tr>
<tr>
<td>FILENAME</td>
<td style="text-align:left">当前文件名</td>
</tr>
<tr>
<td>FNR</td>
<td style="text-align:left">同NR，但相对于当前文件</td>
</tr>
<tr>
<td>FS</td>
<td style="text-align:left">字段分隔符(默认是任何空格)</td>
</tr>
<tr>
<td>IGNORECASE</td>
<td style="text-align:left">如果为真，则进行忽略大小写的匹配</td>
</tr>
<tr>
<td>NF</td>
<td style="text-align:left">当前记录中的字段数</td>
</tr>
<tr>
<td>NR</td>
<td style="text-align:left">当前记录数</td>
</tr>
<tr>
<td>OFMT</td>
<td style="text-align:left">数字的输出格式(默认值是%.6g)</td>
</tr>
<tr>
<td>OFS</td>
<td style="text-align:left">输出字段分隔符(默认值是一个空格)</td>
</tr>
<tr>
<td>ORS</td>
<td style="text-align:left">输出记录分隔符(默认值是一个换行符)</td>
</tr>
<tr>
<td>RLENGTH</td>
<td style="text-align:left">由match函数所匹配的字符串的长度</td>
</tr>
<tr>
<td>RS</td>
<td style="text-align:left">记录分隔符(默认是一个换行符)</td>
</tr>
<tr>
<td>RSTART</td>
<td style="text-align:left">由match函数所匹配的字符串的第一个位置</td>
</tr>
<tr>
<td>SUBSEP</td>
<td style="text-align:left">数组下标分隔符(默认值是/034)</td>
</tr>
</tbody>
</table>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>基本上如同c语言的语法</li>
<li>变量不需要声明</li>
<li>全部是全局变量</li>
<li>有关联数组, for in 遍历</li>
</ul>
<blockquote>
<p>正则匹配行</p>
</blockquote>
<p>~ 表示模式开始。// 中是模式。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 输出第二列包含 "th"，并打印第二列与第四列</span></div><div class="line">awk <span class="string">'$2 ~ /th/ &#123;print $2,$4&#125;'</span> log.txt</div><div class="line">awk <span class="string">'/re/ '</span> log.txt</div><div class="line"></div><div class="line"><span class="comment"># 模式取反</span></div><div class="line">awk <span class="string">'$2 !~ /th/ &#123;print $2,$4&#125;'</span> log.txt</div><div class="line">awk <span class="string">'!/th/ &#123;print $2,$4&#125;'</span> log.txt</div></pre></td></tr></table></figure>
<h2 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h2><figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">cat  ./<span class="variable">$&#123;date&#125;</span> | awk <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    if($2 &gt; 4 &amp;&amp; $3 &gt; 1000)&#123;</div><div class="line">        pv[$2]+=$3;</div><div class="line">        time[$2]+=$4</div><div class="line"></div><div class="line">        pvall += $3;</div><div class="line">        timeall += $4;</div><div class="line"></div><div class="line">        if($2 &lt; 8)&#123;</div><div class="line">            pv8 += $3;</div><div class="line">            time8 += $4;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;END&#123;</div><div class="line">    print "&#123;";</div><div class="line">    printf ( "\"%s\":\"%s\",\n", "all",(timeall/pvall) );</div><div class="line">    printf ( "\"%s\":\"%s\",\n", "&lt;8.0",(time8/pv8) );</div><div class="line">    for(i in pv)&#123;</div><div class="line">        if( time[i] &gt; 0 &amp;&amp; pv[i] &gt; 0) &#123;</div><div class="line">            printf ( "\"%s\":\"%s\",\n", i,(time[i]/pv[i]) );</div><div class="line">        &#125;</div><div class="line">    &#125; ;</div><div class="line">    print "&#125;";</div><div class="line">&#125;'  | tac | sed <span class="string">'2s/\,//'</span> | tac &gt; <span class="variable">$datapath</span>/<span class="variable">$date</span></div></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="http://www.runoob.com/linux/linux-comm-awk.html" target="_blank" rel="external">awk教程</a></p>
]]></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[日志统计--数据采集]]></title>
      <url>http://http://localhost:4000/2016/11/27/data-select/</url>
      <content type="html"><![CDATA[<p>大数据时代，数据有着巨大的价值，其中蕴含着用户的大量信息，合理的使用数据，找到数据中有价值的信息可以为产品设计提供依据。用数据说话更令人信服。统计至关重要。</p>
<h2 id="数据挖掘概况"><a href="#数据挖掘概况" class="headerlink" title="数据挖掘概况"></a>数据挖掘概况</h2><p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-27/23115520.jpg" alt="Alt Text"> </p>
<p>数据采集是最核心的问题。数据采集是否丰富，采集的数据是否准确，采集是否及时，都直接影响整个数据平台的应用的效果。这也是本文集中讨论的重点。</p>
<p>准确性，时效性</p>
<p>时效性更多是体现在日志的传输建库上。比如在1个小时内我们就能够使用采集的日志进行分析。</p>
<h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><p>数据采集时一个需要考虑的问题是用前端统计，还是用后端统计。</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-27/41697522.jpg" alt="Alt Text"> </p>
<p>前端统计适合看<strong>趋势，看总量, 和用户行为</strong>日志(点击，浏览，交互，时长等) 。<br>后端统计适合对可靠性，准确性，安全性要求较高的日志统计(订单，金额，帖子, 用户等);</p>
<blockquote>
<p>前端统计最大的问题就是因环境复杂，日志容易丢失</p>
</blockquote>
<p>在做前端统计时，我们时长会遇到前后端日志match不上，前端日志丢失是一个大问题。比如这些场景：</p>
<ul>
<li>统计某个链接的点击量，但是这个链接点击后直接跳走了。</li>
<li>统计页面时长，unload的时候发送的统计丢失了。</li>
<li>img发送请求，跳走或者关闭页面时对象被垃圾回收了。</li>
<li>如果一个页面用户打开后没加载执行完（因为前置js错误、性能延时、主动关闭等）。应该算一个 pv/uv 吗？这种场景下，一般是认为不应该算的, 但是后端无法识别。</li>
</ul>
<blockquote>
<p>业内也有一些解决方案</p>
</blockquote>
<p>针对问题一，我们的目的是希望保证请求能够发送出去，然后再跳转。 方案有很多</p>
<p>一、阻塞式ajax</p>
<p>阻塞页面关闭，当然可以在 readState 为 2 的时候就 abort 请求，因为我们不关心响应的内容，只要请求发出去就行了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(),</div><div class="line">  xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"text/plain;charset=UTF-8"</span>);</div><div class="line">  xhr.open(<span class="string">'post'</span>, <span class="string">'/log'</span>, <span class="literal">false</span>); <span class="comment">// 同步请求</span></div><div class="line">  xhr.send(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>二、暴力死循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  send(data);</div><div class="line">  <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>;</div><div class="line">  <span class="keyword">while</span>(<span class="keyword">new</span> <span class="built_in">Date</span> - now &gt;= <span class="number">10</span>) &#123;&#125; <span class="comment">// 阻塞 10ms</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>三、发送一个图片请求</p>
<p>大部分浏览器都会等待图片的加载，趁这个机会把统计数据发送出去</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  send(data);</div><div class="line">  (<span class="keyword">new</span> Image).src = <span class="string">'http://example.com/s.gif'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>四、通过window.name传递给下一页再发送<br>五、ios下pagehide兼容</p>
<pre><code>unload的兼容性相较于onbeforeonload，onpagehide是最好的。
</code></pre><p>六、localstorage缓存</p>
<p>七、beacon API</p>
<h2 id="业内方案"><a href="#业内方案" class="headerlink" title="业内方案"></a>业内方案</h2><h3 id="TimeMe"><a href="#TimeMe" class="headerlink" title="TimeMe"></a><a href="https://github.com/jasonzissman/TimeMe.js" target="_blank" rel="external">TimeMe</a></h3><p>核心是利用同步ajax请求，在onbeforeonload的时候确保请求发出去。但onbeforeunload有兼容性问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"><span class="keyword">var</span> startTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> timeSpent = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - startTime,</div><div class="line">        xmlhttp= <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    xmlhttp.open(<span class="string">"POST"</span>, <span class="string">"your_url"</span>);</div><div class="line">    xmlhttp.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</div><div class="line">    <span class="keyword">var</span> timeSpentOnPage = TimeMe.getTimeOnCurrentPageInSeconds();</div><div class="line">    xmlhttp.send(timeSpent);</div><div class="line">&#125;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="产品指标"><a href="#产品指标" class="headerlink" title="产品指标"></a>产品指标</h2><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://github.com/aralejs/name-storage" target="_blank" rel="external">同一窗口内跨页面数据传递–window.name</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[cookie跨域共享]]></title>
      <url>http://http://localhost:4000/2016/11/26/cookie/</url>
      <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>cookie能够保存少量的信息在浏览器端。我们知道http协议是无状态的。每次访问，都是一次新的访问，如果我们希望记录一些浏览信息。就需要依靠cookie来存储，比如登陆信息，比如浏览信息。</p>
<p>cookie可以在服务端设置，也可以在客户端设置。其大小和个数有限制。一个cookie大小限制在2k。一个站点最多有20个cookie。</p>
<p>cookie有同源策略，不同域下，是不能读写的。</p>
<p>cookie如果不设置过期时间，则只会保存在内存里面。当浏览器关闭时就会销毁。</p>
<p>如果设置了过期时间，就会以文件的形式保存在硬盘里，到了过期时间就会销毁。</p>
<p>当访问一个域时，这个域下所有的cookie都会被带上在http的请求头里，不管是前端设置的，还是在后端设置的。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=alan;age=11;expires=121321'</span>;</div></pre></td></tr></table></figure>
<p>cookie 是以；分割的键值对字符串。网上有很多教程，这里不多说。<a href="http://www.jb51.net/article/64330.htm" target="_blank" rel="external">基础教程</a></p>
<h2 id="同主域跨域"><a href="#同主域跨域" class="headerlink" title="同主域跨域"></a>同主域跨域</h2><p>默认情况下，cookie只在相同服务端路径下的文件可以访问，设置path=’/‘, 几可以在整个站点共享，跨目录。<br>设置domain=”.baidu.com”, 则相同主域下cookie都可以共享。例如a.baidu.com, 和b.baidu.com </p>
<h2 id="跨主域写"><a href="#跨主域写" class="headerlink" title="跨主域写"></a>跨主域写</h2><p>在SSO单点登录系统中，会有多个主域名，只要登录了其中一个域，那么访问别的域就不需要登录了。实现这个的关键就是跨域的cookie共享。</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-26/97630655.jpg" alt="Alt Text"> </p>
<p>我们可以利用script标签的src属性发送跨域请求。这种方式优点在于我们可以向任意多的域发送请求。并且共享cookie。</p>
<p>例如用户登录了A.com, 获得了服务端写的cookie，其中包含登录的token。这时前端发送跨域请求，并带上获得的token给其他域，其他域再写cookie，这样就共享了一个登录token。用户访问b.com的时候就不要输入登录密码了。</p>
<p><em>也还有别的方案，比如iframe等。我们的目的是传递cookie值就行了。不过iframe的体验不太好，比较trike，这里不多说。</em></p>
<h2 id="跨主域读"><a href="#跨主域读" class="headerlink" title="跨主域读"></a>跨主域读</h2><p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-26/29022526.jpg" alt="Alt Text"> </p>
<p>有时候我们需要读取别的域下的cookie，也可以利用script的跨域能力。<br>在访问a域时，向b域发起跨域请求，b域服务端获取到所有的cookie并以jsonp的形式返回。前端就能拿到cookie信息了。</p>
<blockquote>
<p><strong>跨域读，跨域写都是利用jsonp，或者image的跨域访问的能力，将当前域的信息带到别的域处理，需要后端配合</strong></p>
</blockquote>
<h2 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h2><p>这里不得不提一下cors的几个属性, 当指定携带用户凭证的时候，域名不能使用通配符，必须指定详细的域名。<br>且，<code>cookie仍然遵循同源策略，所以只有当前服务器的域名设置的cookie才能携带</code>，不能携带客户端cookie，所以<code>cors不能实现跨域cookie共享</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Access-Control-Allow-Credentials : true  // 携带用户凭证，cookie</div><div class="line">Access-Control-Allow-Origin : http://www.baidu.com  // 指定可跨域的域名</div></pre></td></tr></table></figure>
<h2 id="UV统计"><a href="#UV统计" class="headerlink" title="UV统计"></a>UV统计</h2><p>在统计中很常见，统计用户行为轨迹。这个实现一般是在cookie中记录用户的唯一ID。所有的请求都会带上这个唯一ID，在日志分析的时候，按照这个ID merge日志就能得出这个用户的行为了。</p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ominifocus GTD]]></title>
      <url>http://http://localhost:4000/2016/11/23/GTD/</url>
      <content type="html"><![CDATA[<p>每天的事情太多，太杂乱。我们也不知道要去做什么事情好。更何况是对有拖延症的人来说，太过痛苦。<br>Get Things Done。是一件多么牛逼的事情。</p>
<h2 id="GTD-的思想"><a href="#GTD-的思想" class="headerlink" title="GTD 的思想"></a>GTD 的思想</h2><p>收集所有的想法，目的在于快速记录，不让灵感流失。在记录一条idea时，2分钟内能够解决的事情，立马去做。如果不能，就放到收件箱。等待安排。<br>每天定时整理，安排事件</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-23/15309056.jpg" alt="Alt Text"> </p>
<h2 id="ominifocus-的结构"><a href="#ominifocus-的结构" class="headerlink" title="ominifocus 的结构"></a>ominifocus 的结构</h2><p>感觉上比较复杂，其实我们按照GTD的思想来看，也是很好理解。我认为GTD的思想，就是把我们杂乱无序的思绪整理为有条理的一个可循环的圆圈。关键词是focus， 而ominifocus添加了很多辅助能力。让我们能够<strong>专注</strong>于当前需要处理的事情上来。</p>
<ol>
<li>收件箱 </li>
<li>项目</li>
<li>上下文</li>
<li>预测</li>
<li>已标注</li>
<li>检查</li>
</ol>
<p>如果从上到下来看，这些选项就像是一层一层的维度，来帮助我们划分，整理事件。 我需要<strong>强调项目，上下文，预测</strong>这3个维度。</p>
<ol>
<li>项目是从事件本身的复杂程度,和关联性来组织事件</li>
<li>上下文是从用户本身设定场景标识来组织事件</li>
<li>预测是从时间角度来组织事件</li>
</ol>
<p>所以我们在安排事件时，应该是预测(时间)与上下文(场景)结合来看，预测(时间)与项目(关联性)结合来看。 比如我在预测中做了一件事情，发现他有上下文，找到上下文，发现还有一些其他的相关的事情。这时你就可以把他们一并给做了。 <strong>可以看出时间是推动的主轴</strong>。</p>
<blockquote>
<p>收件箱</p>
</blockquote>
<ul>
<li><p>收集所有的想法，目的在于快速记录，不让灵感流失。</p>
</li>
<li><p>在记录一条idea时，2分钟内能够解决的事情，立马去做。如果不能，就放到收件箱。等待安排。</p>
</li>
</ul>
<blockquote>
<p>整理</p>
</blockquote>
<ol>
<li><p>每天都必须要做的工作，我选择在晚上睡觉前，整理收件箱</p>
</li>
<li><p>给未来2到3天安排工作，添加截止日期，删除无意义的idea。</p>
</li>
<li><p>如果一件事情比较复杂，就立项, 拆分步骤。</p>
</li>
<li><p>给事情标注上下文, 小红旗标注重要性。</p>
</li>
</ol>
<blockquote>
<p>处理事件</p>
</blockquote>
<p>在预测面板，我们就能看到今天需要处理的事情了，注意要结合上下文，项目来看。</p>
<blockquote>
<p>专注</p>
</blockquote>
<p>omnifocus处处能够体现让用户专注的特点，</p>
<p>每个事件可以设置小红旗，来标识你最关注的事情,在已标注面板里面，只会显示已经标注的事件。<br><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-23/79636341.jpg" alt="Alt Text"> </p>
<p>在项目里面可以设置项目的状态是否活跃,然后在显示里面可以过滤掉不活跃的项目<br><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-23/51999784.jpg" alt="Alt Text"><br><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-23/49209226.jpg" alt="Alt Text"> </p>
<p>项目里面还可以设置聚焦到当前项目，聚焦后，预测里面的事件也会相应过滤<br><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-23/2763880.jpg" alt="Alt Text"> </p>
]]></content>
      
        <categories>
            
            <category> 职业化 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[clearInterval 无法清除定时器]]></title>
      <url>http://http://localhost:4000/2016/11/21/clearTimeoutNotWork/</url>
      <content type="html"><![CDATA[<p>今天遇到一个奇怪的问题，clearTimeout失效了。大概这么一个场景</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>;i++)&#123;</div><div class="line">	<span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'xxxx'</span>);</div><div class="line">	&#125;,<span class="number">3000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">clearInterval(timer);</div></pre></td></tr></table></figure>
<p>结果就是timer依然在运行。浓缩到这么几行代码，可能比较容易看出问题来，但是分散到比较长的代码里面就很难看出来了。</p>
<p>问题就是setInterval重复注册了。每执行setinterval一次，会返回一个注册id，重复执行时，以前的id被覆盖了，就永远也找不到那个id了，当然这个时候调用clearInterval也没用了。</p>
<p><strong>所以避免的方法就是在每次setInterval之前，先clearInterval, 如果有多个定时器，请一定要保存所有的句柄，一旦出现不可控句柄，问题就严重了</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> timer = <span class="literal">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>;i++)&#123;</div><div class="line">	clearInterval(timer);</div><div class="line">	<span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">'xxxx'</span>);</div><div class="line">	&#125;,<span class="number">3000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">clearInterval(timer);</div></pre></td></tr></table></figure>
<blockquote>
<p>总结</p>
</blockquote>
<p>也算是一个坑吧，需要小心注意。setTimeout也是类似的，要注意。</p>
]]></content>
      
        <categories>
            
            <category> 踩过的坑 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[emacs 入门]]></title>
      <url>http://http://localhost:4000/2016/11/20/emacs/</url>
      <content type="html"><![CDATA[<p>本文旨在讲解基本的入门教程。关于emacs和vim，我写了一些心得。可以参考另外一篇文章</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>emacs有很多版本，在mac上，常用的有GNU的官方版，和对mac优化的版本macport。这个版本对mac的特点做了优化，比如平滑滚动等。</p>
<pre><code>brew tap railwaycat/emacsmacport
brew install emacs-mac
</code></pre><p>安装后，在app里面就能找到GUI应用了。如果想启动cli版的emacs，可以改下链接。本来brew安装后是带了cli版本的。但是mac自带了22版本的emacs，太老了。启动的时候会直接启动老本的命令行版本。</p>
<p>本来尝试替换/usr/bin/emacs 的软链，不过mac el captan这个版本之后的加了一个保护策略，System Integrity Protection，对/usr目录没有操作权限。最简单办法就是改下bashrc了。我用zsh，将如下代码放入.zshrc</p>
<pre><code>alias emacs=&apos;/usr/local/Cellar/emacs-mac/emacs-25.1-z-mac-6.1/bin/emacs&apos;
</code></pre><p>如果你使用item2，需要设置一下mate键，否则没有反应。一般来说meta键就是alt键。<br><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-20/21041562.jpg" alt="Alt Text"> </p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>emacs和核心就是lisp函数，所有的操作都是执行lisp函数。<strong>emacs是一个伪装成编辑器的操作系统</strong>这句话想必是非常出名的吧，可以理解emacs就像操作系统一样，提供各种各样的lisp接口以供调用。十分灵活，这也是它强大所在。</p>
<p>比如forward-char  backward-char  previous-line  next-line , 这是最基本的上下移动，默认绑定的快捷键就是Ctrl加指令首字母 C-f/b/p/n。很直观。所以掌握lisp得函数接口非常重要，可以帮助我们记忆快捷键。</p>
<p>不过lisp函数有千千万，不可能所有都记得，所以我们需要一个字典。M-x, 是lisp函数的查询器，支持completion, 回车后可以直接执行。</p>
<pre><code>C = Control 
M = Meta = Alt | Esc 
Del = Backspace 

基本快捷键(Basic) 
C-x C-f &quot;find&quot;文件, 即在缓冲区打开/新建一个文件 
C-x C-s 保存文件 
C-x C-w 使用其他文件名另存为文件 
C-x C-v 关闭当前缓冲区文件并打开新文件 
C-x i 在当前光标处插入文件 
C-x b 新建/切换缓冲区 
C-x C-b 显示缓冲区列表 
C-x k 关闭当前缓冲区 
C-z 挂起emacs 
C-x C-c 关闭emacs 

光标移动基本快捷键(Basic Movement) 
C-f 后一个字符 
C-b 前一个字符 
C-p 上一行 
C-n 下一行 
M-f 后一个单词 
M-b 前一个单词 
C-a 行首 
C-e 行尾 
C-v 向下翻一页 
M-v 向上翻一页 
M-&lt; 到文件开头 
M-&gt; 到文件末尾 

编辑(Editint) 
M-n 重复执行后一个命令n次 
C-u 重复执行后一个命令4次 
C-u n 重复执行后一个命令n次 
C-d 删除(delete)后一个字符 
M-d 删除后一个单词 
Del 删除前一个字符 
M-Del 删除前一个单词 
C-k 移除(kill)一行 

C-Space 设置开始标记 (例如标记区域) 
C-@ 功能同上, 用于C-Space被操作系统拦截的情况 
C-w 移除(kill)标记区域的内容 
M-w 复制标记区域的内容 
C-y 召回(yank)复制/移除的区域/行 
M-y 召回更早的内容 (在kill缓冲区内循环) 
C-x C-x 交换光标和标记 

C-t 交换两个字符的位置 
M-t 交换两个单词的位置 
C-x C-t 交换两行的位置 
M-u 使从光标位置到单词结尾处的字母变成大写 
M-l 与M-u相反 
M-c 使从光标位置开始的单词的首字母变为大写 

重要快捷键(Important) 
C-g 停止当前运行/输入的命令 
C-x u 撤销前一个命令 
M-x revert-buffer RETURN (照着这个输入)撤销上次存盘后所有改动 
M-x recover-file RETURN 从自动存盘文件恢复 
M-x recover-session RETURN 如果你编辑了几个文件, 用这个恢复 

在线帮助(Online-Help) 
C-h c 显示快捷键绑定的命令 
C-h k 显示快捷键绑定的命令和它的作用 
C-h l 显示最后100个键入的内容 
C-h w 显示命令被绑定到哪些快捷键上 
C-h f 显示函数的功能 
C-h v 显示变量的含义和值 
C-h b 显示当前缓冲区所有可用的快捷键 
C-h t 打开emacs教程 
C-h i 打开info阅读器 
C-h C-f 显示emacs FAQ 
C-h p 显示本机Elisp包的信息 

搜索/替换(Seach/Replace) 
C-s 向后搜索 
C-r 向前搜索 
C-g 回到搜索开始前的位置(如果你仍然在搜索模式中) 
M-% 询问并替换(query replace) 

Space或y 替换当前匹配 
Del或n 不要替换当前匹配 
. 仅仅替换当前匹配并退出(替换) 
, 替换并暂停(按Space或y继续) 
! 替换以下所有匹配 
^ 回到上一个匹配位置 
RETURN或q 退出替换 

使用正则表达式(Regular expression)搜索/替换 
可在正则表达式中使用的符号: 
^ 行首 
$ 行尾 
. 单个字符 
.* 任意多个(包括没有)字符 
\&lt; 单词开头 
\&gt; 单词结尾 
[] 括号中的任意一个字符(例如[a-z]表示所有的小写字母) 

M C-s RETURN 使用正则表达式向后搜索 
M C-r RETURN 使用正则表达式向前搜索 
C-s 增量搜索 
C-s 重复增量搜索 
C-r 向前增量搜索 
C-r 重复向前增量搜索 
M-x query-replace-regexp 使用正则表达式搜索并替换 

窗口命令(Window Commands) 
C-x 2 水平分割窗格 
C-x 3 垂直分割窗格 
C-x o 切换至其他窗格 
C-x 0 关闭窗格 
C-x 1 关闭除了光标所在窗格外所有窗格 
C-x ^ 扩大窗格 
M-x shrink-window 缩小窗格 
M C-v 滚动其他窗格内容 
C-x 4 f 在其他窗格中打开文件 
C-x 4 0 关闭当前缓冲区和窗格 
C-x 5 2 新建窗口(frame) 
C-x 5 f 在新窗口中打开文件 
C-x 5 o 切换至其他窗口 
C-x 5 0 关闭当前窗口 

书签命令(Bookmark commands) 
C-x r m 在光标当前位置创建书签 C-x r b 转到书签 
M-x bookmark-rename 重命名书签 
M-x bookmark-delete 删除书签 
M-x bookmark-save 保存书签 
C-x r l 列出书签清单 

d 标记等待删除 
Del 取消删除标记 
x 删除被标记的书签 
r 重命名 
s 保存列表内所有书签 
f 转到当前书签指向的位置 
m 标记在多窗口中打开 
v 显示被标记的书签(或者光标当前位置的书签) 
t 切换是否显示路径列表 
w 显示当前文件路径 
q 退出书签列表 

M-x bookmark-write 将所有书签导出至指定文件 
M-x bookmark-load 从指定文件导入书签 

Shell 
M-x shell 打开shell模式 
C-c C-c 类似unix里的C-c(停止正在运行的程序) 
C-d 删除光标后一个字符 
C-c C-d 发送EOF 
C-c C-z 挂起程序(unix下的C-z) 
M-p 显示前一条命令 
M-n 显示后一条命令 

DIRectory EDitor (dired) 
C-x d 打开dired 
C(大写C) 复制 
d 标记等待删除 
D 立即删除 
e或f 打开文件或目录 
g 刷新当前目录 
G 改变文件所属组(chgrp) 
k 从屏幕上的列表里删除一行(不是真的删除) 
m 用*标记 
n 光标移动到下一行 
o 在另一个窗格打开文件并移动光标 
C-o 在另一个窗格打开文件但不移动光标 
P 打印文件 
q 退出dired 
Q 在标记的文件中替换 
R 重命名文件 
u 移除标记 
v 显示文件内容 
x 删除有D标记的文件 
Z 压缩/解压缩文件 
M-Del 移除标记(默认为所有类型的标记) 
~ 标记备份文件(文件名有~的文件)等待删除 
# 标记自动保存文件(文件名形如#name#)等待删除 
*/ 用*标记所有文件夹(用C-u */n移除标记) 
= 将当前文件和标记文件(使用C-@标记而不是dired的m标记)比较 
M-= 将当前文件和它的备份比较 
! 对当前文件应用shell命令 
M-} 移动光标至下一个用*或D标记的文件 
M-{ 移动光标至上一个用*或D标记的文件 
% d 使用正则表达式标记文件等待删除 
% m 使用正则表达式标记文件为* 
+ 新建文件夹 
&gt; 移动光标至后一个文件夹 
&lt; 移动光标至前一个文件夹 
s 切换排序模式(按文件名/日期) 

或许把这个命令归入这一类也很合适: 
M-x speedbar 打开一个独立的目录显示窗口 

Telnet 
M-x telnet 打开telnet模式 
C-d 删除后一个字符或发送EOF 
C-c C-c 停止正在运行的程序(和unix下的C-c类似) 
C-c C-d 发送EOF 
C-c C-o 清除最后一个命令的输出 
C-c C-z 挂起正在运行的命令 
C-c C-u 移除前一行 
M-p 显示前一条命令 

Text 
只能在text模式里使用 
M-s 使当前行居中 
M-S 使当前段落居中 
M-x center-region 使被选中的区域居中 

宏命令(Macro-commands) 
C-x ( 开始定义宏 
C-x ) 结束定义宏 
C-x e 运行最近定义的宏 
M-n C-x e 运行最近定义的宏n次 
M-x name-last-kbd-macro 给最近定义的宏命名(用来保存) 
M-x insert-kbd-macro 将已命名的宏保存到文件 
M-x load-file 载入宏 

编程(Programming) 
M C-\ 自动缩进光标和标记间的区域 
M-m 移动光标到行首第一个(非空格)字符 
M-^ 将当前行接到上一行末尾处 
M-; 添加缩进并格式化的注释 
C, C++和Java模式 
M-a 移动光标到声明的开始处 
M-e 移动光标到声明的结尾处 
M C-a 移动光标到函数的开始处 
M C-e 移动光标到函数的结尾处 
C-c RETURN 将光标移动到函数的开始处并标记到结尾处 
C-c C-q 根据缩进风格缩进整个函数 
C-c C-a 切换自动换行功能 
C-c C-d 一次性删除光标后的一串空格(greedy delete) 

为了实现下面的一些技术, 你需要在保存源代码的目录里运行&quot;etags 
*.c *.h *.cpp&quot;(或者源代码的其他的扩展名) 
M-.(点) 搜索标签 
M-x tags-search ENTER 在所有标签里搜索(使用正则表达式) 
M-,(逗号) 在tags-search里跳至下一个匹配处 
M-x tags-query-replace 在设置过标签的所有文件里替换文本 

GDB(调试器) 
M-x gdb 在另一个的窗格中打开gdb 

版本控制(Version Control) 
C-x v d 显示当前目录下所有注册过的文件(show all registered files in this dir) 
C-x v = 比较不同版本间的差异(show diff between versions) 
C-x v u 移除上次提交之后的更改(remove all changes since last checkin) 
C-x v ~ 在不同窗格中显示某个版本(show certain version in different window) 
C-x v l 打印日志(print log) 
C-x v i 标记文件等待添加版本控制(mark file for version control add) 
C-x v h 给文件添加版本控制文件头(insert version control header into file) 
C-x v r 获取命名过的快照(check out named snapshot) 
C-x v s 创建命名的快照(create named snapshot) 
C-x v a 创建gnu风格的更改日志(create changelog file in gnu-style)
</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>emacs的主配置文件是~/.emacs，类似~/.vimrc。~/.emacs.d目录是存放插件的。</p>
<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><blockquote>
<p>buffer window frame</p>
</blockquote>
<p>你每打开过一个文件，就会一个对应的buffer，buffer在你关闭编辑器之前是不会消失的，也就是说当你切换到别的文件时，依旧能够切换回来。</p>
<p>buffer其实并不局限于文件，也可以是shell，或者别的模式。</p>
<p>buffer需要在一个window里面展现，当我们左右分屏时，其实是创建了2个window</p>
<p>当你使用GUI版emacs时，还可以创建多个frame，可以理解为tab</p>
<blockquote>
<p>模式</p>
</blockquote>
<p>一个buffer可以有一个major mode和多个minor mode。</p>
<p>编辑不同的buffer使用不同的major mode, 比如编辑js文件，可以使用js2-mode。major mode定义了emacs在特定buffer下的行为，包括命令，展现和按键绑定等。当前的major mode 显示在mode line。你可以手动修改major mode。</p>
<p>minor mode 是辅助major mode 的，比如line-number-mode，auto-fill-mode, 可以有多个。</p>
<blockquote>
<p>按键映射</p>
</blockquote>
<figure class="highlight lisp"><table><tr><td class="code"><pre><div class="line"><span class="comment">; ctrl</span></div><div class="line">(<span class="name">define-key</span> evil-normal-state-map <span class="string">"\C-n"</span> (<span class="name">lambda</span> () (<span class="name">interactive</span>) (<span class="name">dired</span> <span class="string">"./"</span> )) )</div><div class="line"><span class="comment">; c-/</span></div><div class="line">(<span class="name">define-key</span> evil-normal-state-map <span class="string">"\C-_"</span> 'comment-region)</div><div class="line"><span class="comment">; delete</span></div><div class="line">(<span class="name">define-key</span> evil-normal-state-map (<span class="name">kbd</span> <span class="string">"DEL"</span>)  'previous-buffer)</div><div class="line"><span class="comment">; fx</span></div><div class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"&lt;f3&gt;"</span>) 'open-in-browser)</div><div class="line"><span class="comment">; tab</span></div><div class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">"TAB"</span>) 'open-in-browser)</div></pre></td></tr></table></figure>
<h2 id="插件机制"><a href="#插件机制" class="headerlink" title="插件机制"></a>插件机制</h2><blockquote>
</blockquote>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[archlinux]]></title>
      <url>http://http://localhost:4000/2016/11/17/archlinux/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[http 入门]]></title>
      <url>http://http://localhost:4000/2016/11/17/http/</url>
      <content type="html"><![CDATA[<p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。是从WWW服务器传输超文本到本地浏览器的应用层传送协议。特点是无状态。其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1。</p>
<p>HTTP/1.0 每次请求都需要建立新的TCP连接，连接不能复用。HTTP/1.1 新的请求可以在上次请求建立的TCP连接之上发送，连接可以复用。优点是减少重复进行TCP三次握手的开销，提高效率。 注意：在同一个TCP连接中，新的请求需要等上次请求收到响应后，才能发送。</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-12-5/18925668.jpg" alt="Alt Text"> </p>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-12-4/96070069.jpg" alt="Alt Text"> </p>
<h2 id="http-request"><a href="#http-request" class="headerlink" title="http request"></a>http request</h2><blockquote>
<p>请求方法</p>
</blockquote>
<p>请求方法（所有方法全为大写）有多种，各个方法的解释如下：</p>
<table>
<thead>
<tr>
<th>name</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td style="text-align:left">请求获取Request-URI所标识的资源</td>
</tr>
<tr>
<td>POST</td>
<td style="text-align:left">在Request-URI所标识的资源后附加新的数据</td>
</tr>
<tr>
<td>HEAD</td>
<td style="text-align:left">请求获取由Request-URI所标识的资源的响应消息报头</td>
</tr>
<tr>
<td>PUT</td>
<td style="text-align:left">请求服务器存储一个资源，并用Request-URI作为其标识</td>
</tr>
<tr>
<td>DELETE</td>
<td style="text-align:left">请求服务器删除Request-URI所标识的资源</td>
</tr>
<tr>
<td>TRACE</td>
<td style="text-align:left">请求服务器回送收到的请求信息，主要用于测试或诊断</td>
</tr>
<tr>
<td>CONNECT</td>
<td style="text-align:left">保留将来使用</td>
</tr>
<tr>
<td>OPTIONS</td>
<td style="text-align:left">请求查询服务器的性能，或者查询与资源相关的选项和需求</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank" rel="external">请求报头</a></p>
</blockquote>
<p>基本的就不多说了，可以看维基百科。这里列一些特殊的</p>
<table>
<thead>
<tr>
<th>name</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td style="text-align:left">请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td style="text-align:left">请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td style="text-align:left">请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。</td>
</tr>
<tr>
<td>Accept-Language</td>
<td style="text-align:left">请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</td>
</tr>
<tr>
<td>Authorization</td>
<td style="text-align:left">请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</td>
</tr>
<tr>
<td>Host</td>
<td style="text-align:left">请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg： 我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html" target="_blank" rel="external">http://www.guet.edu.cn/index.html</a> 浏览器发送的请求消息中，就会包含Host请求报头域，如下： Host：www.guet.edu.cn 此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td style="text-align:left">用于告诉服务器，资源的缓存时间</td>
</tr>
<tr>
<td>Referer</td>
<td style="text-align:left">用于告诉服务器，客户机访问服务器通过资源（防盗链）</td>
</tr>
<tr>
<td>User-Agent</td>
<td style="text-align:left">客户机的软件环境</td>
</tr>
<tr>
<td>Cookie</td>
<td style="text-align:left">客户机向服务器带数据</td>
</tr>
<tr>
<td>Connection:close/keep-alive</td>
<td style="text-align:left">一个请求完毕后是关闭连接还是保持连接</td>
</tr>
</tbody>
</table>
<h2 id="http-response"><a href="#http-response" class="headerlink" title="http response"></a>http response</h2><p>HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文</p>
<blockquote>
<p>状态行</p>
</blockquote>
<p>状态行格式 :  HTTP-Version Status-Code Reason-Phrase CRLF<br>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。</p>
<blockquote>
<p>状态码</p>
</blockquote>
<p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p>
<table>
<thead>
<tr>
<th>name</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx：</td>
<td style="text-align:left">指示信息–表示请求已接收，继续处理</td>
</tr>
<tr>
<td>2xx：</td>
<td style="text-align:left">成功–表示请求已被成功接收、理解、接受</td>
</tr>
<tr>
<td>3xx：</td>
<td style="text-align:left">重定向–要完成请求必须进行更进一步的操作</td>
</tr>
<tr>
<td>4xx：</td>
<td style="text-align:left">客户端错误–请求有语法错误或请求无法实现</td>
</tr>
<tr>
<td>5xx：</td>
<td style="text-align:left">服务器端错误–服务器未能实现合法的请求</td>
</tr>
</tbody>
</table>
<p>常见状态代码</p>
<table>
<thead>
<tr>
<th>name</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>200 OK</td>
<td style="text-align:left">客户端请求成功</td>
</tr>
<tr>
<td>400 Bad Request</td>
<td style="text-align:left">客户端请求有语法错误，不能被服务器所理解</td>
</tr>
<tr>
<td>401 Unauthorized</td>
<td style="text-align:left">请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</td>
</tr>
<tr>
<td>403 Forbidden</td>
<td style="text-align:left">服务器收到请求，但是拒绝提供服务</td>
</tr>
<tr>
<td>404 Not Found</td>
<td style="text-align:left">请求资源不存在，eg：输入了错误的URL</td>
</tr>
<tr>
<td>500 Internal Server Error</td>
<td style="text-align:left">服务器发生不可预期的错误</td>
</tr>
<tr>
<td>503 Server Unavailable</td>
<td style="text-align:left">服务器当前不能处理客户端的请求，一段时间后可能恢复正常</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank" rel="external">响应报头</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>name</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>Access-Control-Allow-Origin</td>
<td style="text-align:left">指定跨域共享的站点域名</td>
</tr>
<tr>
<td>Cache-Control: max-age=3600</td>
<td style="text-align:left">缓存时间</td>
</tr>
<tr>
<td>Location</td>
<td style="text-align:left">重定向uri</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td style="text-align:left">服务端设置cookie</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[神之编辑器之神 --- emacs + evil]]></title>
      <url>http://http://localhost:4000/2016/11/17/emacs-evil/</url>
      <content type="html"><![CDATA[<p>了解过vim或者emacs的人都知道，有这么一个说法。<br>emacs是神之编辑器<br>vim是编辑器之神<br>这2大从上古流传下来的神器，在程序界的第一之争，从未停止。犹如.net与java<br>追求极致的人们仍然不停的问自己一个问题。最牛逼的编辑器到底是什么？或许如那一个砸到牛顿的苹果，某位大牛发现了真谛。最牛逼的编辑器，就是emacs + vim 。(哗~~~，晴天霹雳);</p>
<p>我以前是一个而不折不扣的vimer。为她痴迷，为她癫狂。在吐血三升后，我望向了编辑器世界的另一个神话emacs。我希望能够找我苦苦追寻的答案。</p>
<p>一个牛逼的编辑器：</p>
<ol>
<li>速度快</li>
<li>丰富的扩展</li>
<li>容易扩展</li>
<li>高效的编辑</li>
<li>高效的工程管理</li>
</ol>
<p>以上都是浮云，牛逼的编辑器在于，一个好的设计哲学，一个好的先天基因，和强大的扩展能力。任何事物都是在不停演变的，保持强大的扩展能力，自我学习升级的能力才是重中之重。</p>
<p>vim的缺点</p>
<ol>
<li>虽然vim的插件也很多，但是质量参差不齐，插件和插件之间兼容性差。</li>
<li>vim先天不足，vimscrip太烂。</li>
<li>不支持异步任务(vim8.0才有)</li>
<li>冗余配置太多，太杂。</li>
<li>很容易变得臃肿</li>
<li>想在编辑器里面做跟多的事情，显得很乏力,看各种插件文档，看得人想吐。</li>
</ol>
<p>vim的缺点，其实neovim已经改善很多了。但是还需要时间，所以我现在投入了emacs。</p>
<p>emacs的缺点</p>
<ol>
<li>按键绑定太非人类。ctrl到死。</li>
</ol>
<p>当有了evil之后，emacs便没有缺点了。它吸收了vim在编辑效率上的精华。由此也可见emacs强大的扩展能力。emacs给人一种干净，整洁，完整，掌控的感觉。而vim则给人小巧，混乱，控制不住的感觉。</p>
<p>我最明显的一个感觉是。emacs的插件质量和vim的差距完全不在一个量级上。2年时间我看了无数的vim插件文档，搅得头昏脑涨。而我只花了1个星期就将emacs打造得比我的vim还要强大，几乎是无缝迁移而其中我几乎没看什么插件的文档。google一下，前3条内必有wiki，然后照着wiki配置，我一点lisp语言的基础都没有，便实现了插件的个性化配置。真的是感到震惊。这说明emacs的生态是比vim要好的，当然门槛相对而言也高一些。</p>
<p>vim虽然是开源的，但是所有的修改都必须经过作者Bram Moolenaar的同意。neovim就是因为作者不同意修改，而产生的。相对而言emacs更加开放一些。没有那么封闭。</p>
<h2 id="evil"><a href="#evil" class="headerlink" title="evil"></a>evil</h2><h2 id="按键绑定"><a href="#按键绑定" class="headerlink" title="按键绑定"></a>按键绑定</h2><p>evil的按键绑定简单说有2种形式，全局的，和某种mode下的。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><div class="line"><span class="comment">;; 在所有的normal状态下的key-bind</span></div><div class="line">(<span class="name">define-key</span> evil-normal-state-map <span class="string">"\C-n"</span> (<span class="name">lambda</span> () (<span class="name">interactive</span>) (<span class="name">dired</span> <span class="string">"./"</span> )) )</div><div class="line"></div><div class="line"><span class="comment">;; 在特定mode下的key-bind</span></div><div class="line">(<span class="name">evil-define-key</span> 'normal web-mode-map (<span class="name">kbd</span> <span class="string">"TAB"</span>) 'tab-to-tab-stop)</div></pre></td></tr></table></figure>
<p>查看自己当前处于什么major mode</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">c-h v RET major-mode RET</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[前端分层模型演变]]></title>
      <url>http://http://localhost:4000/2016/10/19/dataDriven-md/</url>
      <content type="html"><![CDATA[<p>“上古时代”我们操作视图的基本步骤是：</p>
<p>获取 DOM 对象（大多用 jQuery）<br>获取数据（用任何可能的途径，Ajax 很常见）<br>用新的数据“修改” DOM 对象，或者用新的数据创建新的 DOM 对象（HTML 字符串／模板＋数据对象）<br>更新 DOM<br>这个时候是不存在所谓“视图层”的——视图有，就是我们看得见摸得着的 DOM，但是没有框架层面的抽象视图层，对于视图的操作基本就是纯手工作坊式的。按照今天的话说这叫：以 DOM 为中心。</p>
<p>这种方式的缺点太多了，其中最重要的有两个：</p>
<p>视图没有设计良好的抽象层，你很难有条理的，层次结构分明的去构建 UI 视图<br>一切基于 DOM 的操作带来的是性能上的种种问题，因为 DOM 本身很重<br>然后有人就说了：我们开发应用其实关注的不应该是 DOM，而是数据本身，DOM 只是数据在浏览器里的具体呈现罢了（加上用于表征结构的 HTML 和表征视觉呈现的 CSS 等）。那么我们为什么要穷尽智慧和力气去和 DOM 徒手肉搏呢？我们为什么不能让框架／库为我们做这些事情，好让我们把注意力集中在数据层呢？（其实也就代表着业务逻辑，当数据流转到应用层时，它就是业务逻辑的负载）</p>
<p>于是传统的 MVC 分层理论就以各种各样的方式进入了前端开发的世界……这中间的细节就不多说了。</p>
<p>总之到了今天，像 vue.js 这样的现代框架就是做到了把 DOM 相关的事情隐藏到了框架底层并实现了高度的抽象设计和自动化操作（其实更重要的是对于状态的管理，等你再进阶一些就会体会到 DOM 操作的复杂性终究来源于无序状态的管理），所以作为应用开发者可以最大程度的只把精力放在数据层，也就是具体的业务逻辑上以及 UI 编程上去。</p>
<p>这就是数据驱动视图，你关注数据，框架替你处理视图操作。</p>
<h2 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>mvc</h2><h2 id="mvp"><a href="#mvp" class="headerlink" title="mvp"></a>mvp</h2><h2 id="mvvm"><a href="#mvvm" class="headerlink" title="mvvm"></a>mvvm</h2><blockquote>
<p>vue.js</p>
</blockquote>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[charles抓包工具教程]]></title>
      <url>http://http://localhost:4000/2016/10/09/graspResquest/</url>
      <content type="html"><![CDATA[<p>Charles是mac上的一款比较好用的抓包工具。</p>
<p><strong>在使用Charles代理的时候，需要关闭其他代理。</strong></p>
<p>选择MAC OS X Proxy，自动代理系统的网络请求。<br><img src="http://o99eh3ii0.bkt.clouddn.com//16-10-9/42022369.jpg" alt=""></p>
<p>开始代理，在浏览器访问地址，就可以在监控面板看到了。<br><img src="http://o99eh3ii0.bkt.clouddn.com//16-10-9/22250920.jpg" alt=""></p>
<h2 id="https代理"><a href="#https代理" class="headerlink" title="https代理"></a><a href="https://www.charlesproxy.com/documentation/using-charles/ssl-certificates/" target="_blank" rel="external">https代理</a></h2><p>在访问https的资源的时候，我们会看到请求都是unknown的，这是因为https的代理需要证书。证书下载<a href="http://yun.baidu.com/s/1o6J2Crg" target="_blank" rel="external">http://yun.baidu.com/s/1o6J2Crg</a><br>注意将证书权限设置为始终信任。</p>
<blockquote>
<p>mac </p>
</blockquote>
<p>直接安装, 注意将证书权限设置为始终信任。在help面板里面，有pc端和移动端的证书快捷安装方式。<br><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-12-7/15128752.jpg" alt="Alt Text"> </p>
<blockquote>
<p>ios</p>
</blockquote>
<p>ios 需要下载证书。<a href="http://www.charlesproxy.com/getssl" target="_blank" rel="external">hree</a>。也可以直接安装</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-12-7/27964601.jpg" alt="Alt Text"> </p>
<blockquote>
<p>设置</p>
</blockquote>
<p>设置需要代理的域名，端口为443</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-12-7/38781483.jpg" alt="Alt Text"> </p>
<h2 id="手机请求代理"><a href="#手机请求代理" class="headerlink" title="手机请求代理"></a>手机请求代理</h2><p>手机和电脑需要在同一一个wifi下。<br>打开手机的网络，选择代理，自动。填写电脑的ip，和Charles的监听端口<br><img src="http://o99eh3ii0.bkt.clouddn.com//16-10-10/44283958.jpg" style="width:300px"></p>
<h2 id="证书信任问题"><a href="#证书信任问题" class="headerlink" title="证书信任问题"></a>证书信任问题</h2><p>在高级的ios版本中，代理https可能会出现证书信任问题。 <code>Failure SSLHandshake: Received fatal alert: unknown_ca</code><br>原因是ios高版本中需要手动确认，信任的证书。<code>通用-&gt;关于本机-&gt;证书信任设置 打开才有效果</code></p>
<h2 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h2><p>Charles可以将请求代理到远程链接(mapping remote)，也可以代理到本地文件(mapping local)。</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com/FoLoz_oUlmofKFRliBLjPJRaZ8Ks" alt=""></p>
<p>填写要代理的path，代理到的path。</p>
<p>这里有个技巧，<strong>把完整的path拷贝填入host，然后光标移动到下面的输入框</strong>，就会自动拆解填入</p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[心经解读笔记]]></title>
      <url>http://http://localhost:4000/2016/10/08/heartSutra/</url>
      <content type="html"><![CDATA[<p>观自在菩萨,行深般若波罗蜜多时，照见五蕴皆空，度一切苦厄。</p>
<p>这是般若经的总纲.</p>
<p>舍利子，色不异空，空不异色，色即是空，空即是色，受想行识，亦复如是。舍利子，是诸法空相，不生不灭，不垢不净，不增不减。是故空中无色，无受想行识，无眼耳鼻舌身意，无色声香味触法，无眼界，乃至无意识界。无无明，亦无无明尽，乃至无老死，亦无老死尽。无苦集灭道，无智亦无得。</p>
<p>般若的要义</p>
<p>以无所得故，菩提萨埵，依般若波罗蜜多故，心无罣碍，无罣碍故，无有恐怖，远离颠倒梦想，究竟涅磐。<br>修般若得到的成就</p>
<p>三世诸佛，依般若波罗蜜多故，得阿耨多罗三藐三菩提。故知般若波罗蜜多，是大神咒，是大明咒，是无上咒，是无等等咒，能除一切苦，真实不虚。</p>
<p>故说般若波罗蜜多咒，即说咒曰：揭谛揭谛 波罗揭谛 波罗僧揭谛 菩提萨婆诃。</p>
<h2 id="空的理解"><a href="#空的理解" class="headerlink" title="空的理解"></a>空的理解</h2><p>空不是“无”，而是“无自性”的意思,说“色是空”，不是说“色不存在”，而是说“色无自性”。<br>自性的含意，其实就是“实在的、常住的、独存的”<br>缘起故而性空，这就是“色即是空”；性空方能缘起，这就是“空即是色”。缘起与性空不二；色与空不二。</p>
<p>人所感知的一切，本质上都是空相，无自性，可是这些东西又实实在在的存在于我们的生活里。我们生活在我们以为的那个”我”的生活里。我们要好好的去生活，一切皆真实，尽心尽力。我们也要看破生活的这个梦幻泡影的本质，让心平静下来，不再涤荡起伏，执着，则无有恐怖，随喜功德。空相就是什么都没有，连空的概念都没有，一片混沌，不可思议,既不着无，也不着有。应无所住，而生其心。</p>
<h2 id="因缘"><a href="#因缘" class="headerlink" title="因缘"></a>因缘</h2><p>于一切果中，察一切因。当知前生无恶不造，一一当忏悔<br>一切法无主宰，也非自然，是因缘所生。因缘道理是全部佛法的基础。<br>因缘生法就是：缘聚，这个相就现前；缘散，这个相就灭了。你不要等到缘散才晓得这是空的，正在聚合的时候，你就能看出这是假的、假相，不是真的。所以佛才讲：“凡所有相，皆是虚妄。<br>因果为什么不空？因，实在说，也是剎那之间就变成果；因变成果，因空了。果，又是下一个果的因，所以果又变成因；果变成因，果也空了。由此可知，因果也是空的。因果怎么会不空？因果不空，前面这一句话就讲不通。“万法皆空”，因果是不是属于万法里面的？还是万法以外的？当然属于万法里面的。万法皆空，因果也空。何以说“因果不空”？因果“转变不空”，因会变成果，果会变成因，说它的转变不空，是说这个意思。另外一个意思，因果“相续不空”，永远是相续的。我们一个人，造业是因，受报是果，受报的时候，他又造业，永远在相续，永远在循环。所以“因果不空”是讲它三个特性，<strong>转变、相续、循环</strong>，这三个不空。</p>
<p>性空无我率<br>因果循环率<br>“缘起性空”的道理，是说明一切法现象和本质二者之间的关系。佛从“空”来看待一切事物，又不废一法；从“有”来看待一切事物，又不立一法。<br>佛教是三世因果论者，主张一切众生的生命，是无限延续的，宛如大河流水，滔滔不尽，激起层层浪花。众生的生与死，不过是生命之流中浪花的泛起与消散而已。这一定律，是佛教的人生观。它能使人们充满希望，鼓足勇气，看清前途，努力创造自己和人类美好的未来。</p>
<h2 id="顿悟法门"><a href="#顿悟法门" class="headerlink" title="顿悟法门"></a>顿悟法门</h2><p>菩提本无树，明镜亦非台，本来无一物，何处染尘埃。这是六祖慧能法师所作谒。</p>
<p>其一、在修禅的指导思想上,“立无念为宗,无相为体,无住为本。”认为,由心随缘而起生成的现象世界,空无所有,而自心是实,亦是真如本体和佛性,事物既然是意念所造,就不应执以为“有”,不要去思辩事物的真假、是非、美丑、是为“无念”。但无念并非泯绝一切思维,不能修空住空。应唯以真如为念,方是正念,才是成佛之路。通过无念的直觉,直接体悟真如佛性,不劳去除妄念。无念的理论前提即是“无相”。相指世界一切现象,现象由心造成,并不实在,只有不执著现象为实有,才能认识真如实相,此名无相。真如无相,无法看到,只能体会。也只能远离一切相,才能体悟真如佛性而成佛道。欲成佛道,须有佛智。对任何事物无所住心、无所拟著、无所取舍,没有固定的见解和特定的心理趋向,即是“无住”。具备了无住的条件,就是成就了佛智慧。</p>
<p>“应无所住”既不著有，“而生其心”亦不落无. 体用不二<br>应无所住，就是一切不住。若能一切不住，即是实相境界。既悟实相无相，一无所得，还有什么我执、烦恼、生死、无明可住？若执著无住，又落于偏空。何以故？当知真空不空。云何不空？空寂灵知，起用自见。用云何起？依般若智而生其心，即是起用。云何生心？即生吾人本具之妙明真心，<strong>就是生悲愿无尽之菩萨心、菩提心、慈悲心、平等心、利他无我心。如是等心，皆是无所住而生之心。便是真心、清净心，亦即是佛心</strong>。而众生所生之心，乃贪心、我执心、贡高心、差别心，乃至八万四千烦恼心。如是等心，皆是有所住而生之心，便是妄心、业识心，亦即是众生心。所以者何？因众生处处著相，相多故心亦多，心多即不能清净，心不清净，即不能悟得实相真心。故学佛人欲悟实相真心，即要放下一切，则一切不住，真心自见，即是道心。道从心生，心由道见。讲到究竟，这一个道字，也不可说。所谓言语道断，心行路绝。此理微妙，初学人不易领悟。佛要人领悟实相无相，离念即是真心，故说“应无所住”。佛又要人领悟起用之妙，故又方便说“而生其心”，“应无所住，而生其心”二句，看来似觉矛盾，其实就是如是。</p>
<h2 id="言语道断，心行处灭"><a href="#言语道断，心行处灭" class="headerlink" title="言语道断，心行处灭"></a>言语道断，心行处灭</h2><p><a href="http://bbs.tianya.cn/post-647-31002-1.shtml" target="_blank" rel="external">http://bbs.tianya.cn/post-647-31002-1.shtml</a></p>
]]></content>
      
        <categories>
            
            <category> 佛法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机编码的来龙去脉]]></title>
      <url>http://http://localhost:4000/2016/10/07/encode/</url>
      <content type="html"><![CDATA[<h2 id="计算机编码的基本原理"><a href="#计算机编码的基本原理" class="headerlink" title="计算机编码的基本原理"></a>计算机编码的基本原理</h2><p>在计算机内部，所有信息都会被表示成二进制码，即0，1串。人们约定8位二进制为一个byte。byte是计算机的最小存储单元。</p>
<p>a. 1 bit = 2种两种可能性 ,0/1<br>b. 1 byte = 8 bit<br>c. 1 byte = 2 ^ 8 次方 = 256 种可能性<br>d. 1 byte 可以给256个字符编码</p>
<h2 id="计算机编码的发展史"><a href="#计算机编码的发展史" class="headerlink" title="计算机编码的发展史"></a>计算机编码的发展史</h2><blockquote>
<p>ASCII -&gt; unicode -&gt; utf(8,16) [世界发展]</p>
</blockquote>
<p>为了存储以及展现字符，人们就用这8个二进制的编码来标识字符。计算机最开始只支持英文，使用了0-127就可以完整标识英文了，这套编码就叫<strong>ASCII</strong>码。</p>
<p>后来欧洲的国家也使用计算机，某些符号不能表示，于是他们就是用了剩下的128-255码位来标识。</p>
<p>再后来中国也开始使用计算机，中国汉字有10万左右，一个字节已经不够了标识了。于是就是用2个字节来标识。理论上可以表示 256 x 256 = 65536个字，常用汉字也就7000多个。完全可以满足日常使用了。这套编码就是<strong>GB2312</strong>。</p>
<p>计算机开始遍布全球，其他国家也开始了定制自己的字符集。这造成了一个问题，跨文字的沟通变得困难，同一个二进制码在不同字符集中代表不同意义，想要精确知道原文含义，就必须安装相应文字的字符集。否则就会出现乱码。</p>
<p>这时出现了一个组织叫ISO，他们搞出了一套编码叫<strong>Unicode</strong>,致力于统一所有语言的字符编码,<strong>作为不同文字之间的转换桥梁</strong>。</p>
<p>Unicode默认用2个字节来标识一个字符，这样在存储英文的时候，耗费的空间会多一倍。随着互联网的兴起，带宽是很昂贵的，所以后来就出现了UTF类的传输编码，如<strong>utf8</strong>。 它是可以变长编码，能使用1-6个字节来标识字符。目的在于节省传输开销。</p>
<blockquote>
<p>ASCII -&gt; GB2312 -&gt; GBK -&gt; GB18030    [中文发展]</p>
</blockquote>
<h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><p>GB2312是中国国家标准<strong>简体中文</strong>字符集<br>GB 2312标准共收录6763个汉字，其中一级汉字3755个，二级汉字3008个；同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个字符。<br>GB2312对任意一个图形字符都采用两个字节表示。 与ASCII有重叠，通行方法是将GB码两个字节的最高位置1以示区别。<br>GB2312基本满足日常使用，但对汉字的收录还是太少了，对于人名、古汉语等方面出现的罕用字，GB 2312不能处理，这导致了后来GBK及GB 18030汉字字符集的出现。</p>
<h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>GBK即汉字内码<strong>扩展规范</strong>，K为汉语拼音 Kuo Zhan（扩展）中“扩”字的声母。英文全称Chinese Internal Code Specification。<br>GBK共收入21886个汉字和图形符号，包括：<br>GB2312中的全部汉字、非汉字符号。<br>BIG5中的全部汉字。<br>与ISO 10646相应的国家标准GB13000中的其它CJK汉字，以上合计20902个汉字。<br>其它汉字、部首、符号，共计984个。</p>
<h3 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h3><p>GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的PC平台必须支持GB18030，对嵌入式产品暂不作要求。所以手机、MP3一般只支持GB2312。</p>
<p>GB18030有两个版本：GB18030-2000和GB18030-2005。GB18030-2000是GBK的取代版本，它的主要特点是在GBK基础上增加了CJK统一汉字扩充A的汉字。GB18030-2005的主要特点是在GB18030-2000基础上增加了CJK统一汉字扩充B的汉字。<br>GB18030可用于<strong>一切处理中文</strong>（包括汉字和少数民族文）信息，特别是汉字信息的信息处理产品</p>
<p>GB18030像utf8一样是变长编码，1-4个字节。</p>
<blockquote>
<p>总结</p>
</blockquote>
<p>从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理。区分中文编码的方法是高字节的最高位不为0。</p>
<h2 id="编码详解"><a href="#编码详解" class="headerlink" title="编码详解"></a>编码详解</h2><blockquote>
<p>unicode</p>
</blockquote>
<p>“Universal Multiple-Octet Coded Character Set”,简称为UCS。UCS可以看作是”Unicode Character Set”的缩写。ucs-2标识用2个字节标识一个字符。还有ucs-4版，用4个字节来标识。</p>
<blockquote>
<p>utf8/utf16</p>
</blockquote>
<p>UCS规定了怎么用多个字节表示各种文字。怎样传输这些编码，是由UTF(UCS Transformation Format)规范规定的，常见的UTF规范包括UTF-8、UTF-7、UTF-16。</p>
<p>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。<br>UTF-8的编码规则很简单，只有二条：<br>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
<p>Unicode符号范围 | UTF-8编码方式<br>(十六进制) | （二进制）<br>——————–+———————————————<br>0000 0000-0000 007F | 0xxxxxxx<br>0000 0080-0000 07FF | 110xxxxx 10xxxxxx<br>0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx<br>0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</p>
<p>跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。<br>下面，还是以汉字”严”为例，演示如何实现UTF-8编码。<br>已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5。</p>
<h3 id="utf8和Unicode的区别"><a href="#utf8和Unicode的区别" class="headerlink" title="utf8和Unicode的区别"></a>utf8和Unicode的区别</h3><p>utf8是基于Unicode发展起来的。并没有改变编码，只是定义了一套存储方式. <strong>是对Unicode的再编码</strong>。<br>unicode规定了字符的唯一编码，但没有规定如何存储，utf8规定了如何存储,传输。<br>utf8是国际标准，支持世界上所有的语言，但是具体到某一个语言上，还是没有特定的字库支持好。</p>
<blockquote>
<p>总结</p>
</blockquote>
<p>utf8和gbk编码并不兼容，但他们都向下兼容ASCII编码。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.zhihu.com/question/19677619" target="_blank" rel="external">3种中文编码的区别</a><br><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[js设计模式-桥接模式]]></title>
      <url>http://http://localhost:4000/2016/09/24/js-design-pattern-Bridge/</url>
      <content type="html"><![CDATA[<p>桥接模式的作用在于将实现部分和抽象部分分离开来， 以便两者可以独立的变化。在实现api的时候， 桥接模式特别有用。<br>运用好桥接模式，对软件的扩展性和健壮性而言有莫大好处。它提醒开发者，要分清楚什么是实现，什么抽象。在面对多种环境的时候,我们要做的是面向接口编程，面向抽象编程。实现可以在运行时确定。将纵向的依赖拉平。或者说是找到抽象与实现之间真实的依赖,它是不容易改变的。</p>
<p>动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。<br>这一切都建立在鸭子类型（duck typing）的概念上，鸭子类型的通俗说法是：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。”</p>
<p>这个故事告诉我们，国王要听的只是鸭子的叫声，这个声音的主人到底是鸡还是鸭并不重要。鸭子类型指导我们只关注对象的行为，而不关注对象本身，也就是关注HAS-A, 而不是IS-A。</p>
<p>javscript不需要接口这种超类型的帮助，它并没有真实的类，只有对象。任意对象的任意方法都可以被复用。</p>
<p>什么时候去使用桥接模式:</p>
<ol>
<li>你想在运行时确认实现，</li>
</ol>
<p>常用的桥接手段</p>
<ol>
<li>代码复用 （实现继承是强依赖，接口继承是若依赖）</li>
<li>扩展性，稳定性强</li>
</ol>
<p>将事物抽象，面向抽象编程。因为抽象的东西是不容易变的。</p>
<blockquote>
<p>回调</p>
</blockquote>
<p>运行时确认方法逻辑。</p>
<blockquote>
<p>抽象接口</p>
</blockquote>
<p>运行时确定类的定义。</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[js设计模式-单例模式]]></title>
      <url>http://http://localhost:4000/2016/09/24/js-design-pattern-Singleton/</url>
      <content type="html"><![CDATA[<p>在一些底层框架中，会很常见单例模式。即一个类只返回同一个实例。避免资源浪费，或者多实例争夺一份资源时的冲突。<br>js非常灵活，有很多种方式实现单例模式。这里介绍常见的几种。</p>
<blockquote>
<p>字面量</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">name</span> : <span class="string">'fda'</span>,</div><div class="line">    <span class="attr">age</span> : <span class="string">'fds'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对象字面量是最简单的单例模式。但是实例是提前确定的。</p>
<blockquote>
<p>缓存到构造函数上</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Global</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">// 缓存到构造函数的静态方法中</span></div><div class="line">   <span class="comment">// 弊端是外部可以修改实例属性</span></div><div class="line">   <span class="keyword">if</span> ( <span class="keyword">typeof</span> Global.instance === <span class="string">'object'</span> ) &#123;</div><div class="line">       <span class="keyword">return</span> Global.instance;</div><div class="line">   &#125;</div><div class="line">   Global.instance = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">   <span class="comment">// 初始化</span></div><div class="line">   <span class="keyword">this</span>.name = <span class="string">'Singleton'</span>;</div><div class="line">   <span class="keyword">this</span>.age = <span class="number">12</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g1 = <span class="keyword">new</span> Global();</div><div class="line"><span class="keyword">var</span> g2 = <span class="keyword">new</span> Global();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( g1 === g2);</div></pre></td></tr></table></figure>
<p>缓存实例，判断是否存在，存在即返回。可以在第一次new的时候确定实例。</p>
<blockquote>
<p>缓存到闭包里面</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 推荐</span></div><div class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 缓存到闭包中</span></div><div class="line">    <span class="keyword">var</span> instance; </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">per</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">if</span> ( <span class="keyword">typeof</span> instance === <span class="string">'object'</span> ) &#123;</div><div class="line">           <span class="keyword">return</span> instance;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       instance = <span class="keyword">this</span>;</div><div class="line">       <span class="comment">// 初始化</span></div><div class="line">       <span class="keyword">this</span>.name = <span class="string">'Singleton'</span>;</div><div class="line">       <span class="keyword">this</span>.age = <span class="number">123</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> per;</div><div class="line">&#125;)()</div><div class="line"></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(p1 === p2);</div></pre></td></tr></table></figure>
<p>缓存实例到闭包里面，这样外部就不能修改了。</p>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[随记]]></title>
      <url>http://http://localhost:4000/2016/09/17/sj/</url>
      <content type="html"><![CDATA[<p>人都是会死的，生前执着的东西，死了就什么都没了。佛法讲来生，这样的人生观或许有些道理。让我们不至于陷入当前的悲欢离合。放到人生的角度来说，那只是人生的一个小小曲折，或是思想上的一段波澜。放到轮回来说，那更是如大海中的涟漪。人生很长，所以很多事，并没有你想象的那般晴天霹雳，或是手舞足蹈。</p>
<p>珍爱一切而随顺自然，静随人生走向。外经变迁翻滚，自内心坚定不惊。</p>
<p>世间的道德绑架，有人没有意识，将仪式和感情合二为一,这是世间公理，有人跳出感情而质疑仪式，为世间所不容。跳出感情却执行仪式，它可以是为了逃避世俗批判而伪装(为己)。也可以是看破一切后的平静，成全(为人)。它可以是真，也可以是假。还是取决于心，不取决与法。而天道无情，连心都没有(不为人，不为己)。这似乎显得很冷漠。。</p>
<p>天之道损有余而补不足(谁也不为)，人之道损不足以奉有余(为自)</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[增强neovim(vim)的代码编辑体验]]></title>
      <url>http://http://localhost:4000/2016/09/13/vim-edit-enhance/</url>
      <content type="html"><![CDATA[<p>原生的vim，编辑效率已经很高，但要让编程变得轻松，甚至享受，还需要一些神级插件的加持。有了这些插件，vim的编辑体验完全不输于任何IDE</p>
<h2 id="代码完成"><a href="#代码完成" class="headerlink" title="代码完成"></a>代码完成</h2><p>YouCompleteMe + ultisnips + superTab + tern_js</p>
<p>这恐怕是身为一个代码编辑器最重要的能力了。vim自带有miniComplete，效果一般且只能手动触发。其他代码完成插件本人也尝试过很多这里也不提了，直接上终极插件</p>
<blockquote>
<p><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="external">YouCompleteMe</a></p>
</blockquote>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-15/53439318.jpg" alt="pic alt"></p>
<p>youCompleteMe是一个非常出色的vim代码完成引擎，支持大部分语言，可以结合别的语言分析引擎，比如<strong>tern</strong>(js语义分析引擎),编译的时候添加对应的编译属性</p>
<ul>
<li>对c，c++ c#等语言支持最好,支持c族语言的语法检查,跳转到变量声明，查找引用等</li>
<li>自动补全出现过，或者打开过的buffer里的字符串，无需按快捷键,支持模糊匹配</li>
<li>当按下.  / -&gt; / :: 时，进行语义补全，提示各种功能函数，变量</li>
<li>支持文件路径补全</li>
<li>可以与UltiSnips集成,在提示列表中显示snips，并补全</li>
</ul>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>使用插件管理器安装，Vundle/Pathogen/vim-plug,我用的是vim-plug<br><code>Plug &#39;Valloric/YouCompleteMe&#39;</code><br>如果手动git下载，请确保执行<code>git submodule update --init --recursive</code></p>
<h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p><code>cd ~/.vim/bundle/YouCompleteMe</code><br><code>./install.py --tern-completer</code><br>可以加上别的语言编译器属性，写js的话就加上<code>--tern-completer</code>。或者啥都要’–all’。详情请看官方文档</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul>
<li>如果更新了插件，需要重新编译</li>
<li>vim版本在7.3.598以上,支持Python 2 或者 Python 3,没有的话，重新编译一个vim</li>
</ul>
<h5 id="配置tern"><a href="#配置tern" class="headerlink" title="配置tern"></a>配置tern</h5><p>在工程目录下创建.tern-project文件，基础配置如下，详情可以看下tern的<a href="http://ternjs.net/doc/manual.html#configuration" target="_blank" rel="external">官方文档</a><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"libs"</span>: [</div><div class="line">    <span class="string">"browser"</span>,</div><div class="line">    <span class="string">"jquery"</span></div><div class="line">  ],</div><div class="line">  <span class="string">"plugins"</span>: &#123;</div><div class="line">        <span class="string">"node"</span>: &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>( tern_js 和YCM是可以分开使用的，不用编译的时候带上，但要全局npm 安装。在我的测试来看，我感觉编译带上后，提示要快很多。而且tern-project的配置不要也可以完成提示，而且是自动根据语义提示是browser还是jqeury还是node。看到这里的朋友可以注意一下,不清楚是不是都是这样。 )</p>
<h5 id="兼容ultisnips-Tab补全"><a href="#兼容ultisnips-Tab补全" class="headerlink" title="兼容ultisnips Tab补全"></a>兼容ultisnips Tab补全</h5><p>默认情况下，YCM和ultisnips都是用tab补全，会有冲突。目前有2个解决方案。第一个就是给其中一个换一个trigger_key,这样2者完全不会冲突。第二个方案就通过superTab做桥梁，兼容二者。</p>
<p><code>Plug &#39;ervandew/supertab&#39;</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot; make YCM compatible with UltiSnips (using supertab)</div><div class="line">let g:ycm_key_list_select_completion = [&apos;&lt;C-n&gt;&apos;, &apos;&lt;Down&gt;&apos;]</div><div class="line">let g:ycm_key_list_previous_completion = [&apos;&lt;C-p&gt;&apos;, &apos;&lt;Up&gt;&apos;]</div><div class="line">let g:SuperTabDefaultCompletionType = &apos;&lt;C-n&gt;&apos;</div><div class="line"></div><div class="line">&quot; better key bindings for UltiSnipsExpandTrigger</div><div class="line">let g:UltiSnipsExpandTrigger = &quot;&lt;tab&gt;&quot;</div><div class="line">let g:UltiSnipsJumpForwardTrigger = &quot;&lt;tab&gt;&quot;</div><div class="line">let g:UltiSnipsJumpBackwardTrigger = &quot;&lt;s-tab&gt;&quot;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h2><p>neomake + eslint</p>
<blockquote>
<p><a href="neomake/neomake">neomake</a></p>
</blockquote>
<p>neomake是一个异步执行:make的插件,使用neovim的job control功能。常见的用途就是结合代码检查插件，进行异步检查,避免阻塞vim UI。类似<a href="">Syntastic</a>。vim也能使用，不过没有异步的能力。</p>
<h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p><code>Plug &#39;neomake/neomake&#39;</code><br><code>autocmd! BufWritePost * Neomake</code><br><code>let g:neomake_javascript_enabled_makers = [&#39;eslint&#39;]</code><br><strong>注意</strong> 需要全局npm安装eslint</p>
<blockquote>
<p>eslint</p>
</blockquote>
<p>eslint是一个ECMAScript/JavaScript代码检查工具，类似JSHint/JSLint,但是配置更灵活，检查更强大。</p>
<h5 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h5><p><code>npm install -g eslint</code><br>在工程目录下执行<code>eslint --init</code>,进入交互式配置，生成.eslintrc.json配置文件</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>eslint的配置主要有3个概念 – env , rules , globals<br><strong>env</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"env"</span>: &#123;</div><div class="line">        <span class="string">"browser"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"node"</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>是环境配置，代表了一套检查规则,可以快速配置。eslint自带了这些环境配置<br><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-15/44680460.jpg" alt="pic alt"></p>
<p><strong>globals</strong><br>可以指定全局变量以避免eslint检查报错undefined<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"globals"</span>: &#123;</div><div class="line">        <span class="string">"var1"</span>: <span class="literal">true</span>,</div><div class="line">        <span class="string">"var2"</span>: <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>rules</strong><br>详细配置每一条规则，每条规则的报错级别有3个可选项，必选其一。有些规则还有别的属性。全部规则请看<a href="http://eslint.org/docs/rules/" target="_blank" rel="external">官方文档</a>。</p>
<p>默认所有规则都是关闭的，可以配置<code>&quot;extends&quot;: &quot;eslint:recommended&quot;</code>属性，开启常用rules。</p>
<ul>
<li>“off” or 0 - turn the rule off</li>
<li>“warn” or 1 - turn the rule on as a warning (doesn’t affect exit code)</li>
<li>“error” or 2 - turn the rule on as an error (exit code is 1 when triggered)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"rules"</span>: &#123;</div><div class="line">        <span class="string">"eqeqeq"</span>: <span class="string">"off"</span>,</div><div class="line">        <span class="string">"curly"</span>: <span class="string">"error"</span>,</div><div class="line">        <span class="string">"quotes"</span>: [<span class="string">"error"</span>, <span class="string">"double"</span>]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>语言版本</strong><br><code>parserOptions</code>选项配置ecma的版本，已经其他扩展能力，如jsx</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"parserOptions"</span>: &#123;</div><div class="line">        <span class="string">"ecmaVersion"</span>: <span class="number">6</span>,</div><div class="line">        <span class="string">"sourceType"</span>: <span class="string">"module"</span>,</div><div class="line">        <span class="string">"ecmaFeatures"</span>: &#123;</div><div class="line">            <span class="string">"jsx"</span>: <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"rules"</span>: &#123;</div><div class="line">        <span class="string">"semi"</span>: <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="文件-代码查找"><a href="#文件-代码查找" class="headerlink" title="文件/代码查找"></a>文件/代码查找</h2><p>fzf + ag</p>
<blockquote>
<p><a href="https://github.com/junegunn/fzf" target="_blank" rel="external">fzf</a></p>
</blockquote>
<p>fzf是一个用go语言写的命令行模糊查询工具。可以与vim结合使用。它的速度很快。<br>fzf是一个通用筛选工具，你可以自己指定它的数据源，然后用fzf来筛选。</p>
<h5 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h5><p><code>sudo brew install fzf</code><br>直接在命令行下执行 <code>fzf</code>就会查询当前目录下的所有文件。但是当你选择一个文件按下回车时，没有任何动作，只是简单的输出文件路径。<br>fzf默认是find命令来查找文件，你可以换成别的命令，或者直接给出数据源。</p>
<h5 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h5><p><code>Plug junegunn/fzf.vim</code>  下载插件<br><code>set rtp+=~/.fzf</code> 如果是homebrew安装，需要设置这句话</p>
<h5 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:Files      查询文件</div><div class="line">:Buffers    查询buffers</div><div class="line">:History    查询历史打开过的文件</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://github.com/ggreer/the_silver_searcher" target="_blank" rel="external">ag</a></p>
</blockquote>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-16/19872916.jpg" alt="pic alt"><br>ag是一个命令行下的代码查询工具。 ag &gt; ack &gt; grep 。 查询速度非常快 。 可以和vim结合，查找的结果放在一个buffer中。<br>它会自动忽略git/hg/svn-ignore的忽略内容。</p>
<h5 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h5><p><code>sudo brew install the_silver_searcher</code><br><code>Plug &#39;rking/ag.vim&#39;</code></p>
<h5 id="与fzf结合"><a href="#与fzf结合" class="headerlink" title="与fzf结合"></a>与fzf结合</h5><p>安装fzf后，执行 <code>:Ag someword</code>,其结果可以用fzf筛选。<br><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-16/74584269.jpg" alt="pic alt"></p>
<h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h2><p>autoFomate + js-beautiful</p>
<h2 id="括号补全"><a href="#括号补全" class="headerlink" title="括号补全"></a>括号补全</h2><h2 id="终端模拟"><a href="#终端模拟" class="headerlink" title="终端模拟"></a>终端模拟</h2><p>neoterm<br>vimshell</p>
]]></content>
      
        <categories>
            
            <category> vim </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[samba配置文件共享服务]]></title>
      <url>http://http://localhost:4000/2016/09/13/samba/</url>
      <content type="html"><![CDATA[<h1 id="测试机配置samba服务"><a href="#测试机配置samba服务" class="headerlink" title="测试机配置samba服务"></a>测试机配置samba服务</h1><p>samba可以使我们本地跟测试机连通，从而提高开发效率<br>首先你得有<code>root</code>帐户，和<code>work</code>帐户</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用<code>yum</code>安装：<code>yum -y install samba</code></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote>
<p>使用<code>root</code></p>
</blockquote>
<p>修改<code>vi /etc/samba/smb.conf</code>，添加以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 全局配置</div><div class="line">workgroup = WORKGROUP</div><div class="line">security = user</div><div class="line"></div><div class="line"></div><div class="line"># 这下是配置work</div><div class="line">[work]</div><div class="line">   comment = home work</div><div class="line">   path = /home/work</div><div class="line">   public = no</div><div class="line">   browseable = yes</div><div class="line">   writable = yes</div><div class="line">   valid users = work</div></pre></td></tr></table></figure>
<p>再执行<code>smbpasswd -a work</code>添加帐户到<code>samba</code></p>
<p>保存后可用<code>testparm</code>查看配置是否有问题</p>
<p>查看<code>/home/work</code>是否有<code>work</code>权限，没有则进入<code>root</code>添加所有者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">chown work:work -R /home/work/</div></pre></td></tr></table></figure>
<p>再添加<code>work</code>的权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">chmod -R 744 /home/work</div></pre></td></tr></table></figure>
<p>执行<code>/etc/init.d/smb start</code>启动</p>
<h2 id="本地链接测试机"><a href="#本地链接测试机" class="headerlink" title="本地链接测试机"></a>本地链接测试机</h2><h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><p>打开<code>Finder</code>，按<code>command+k</code>（或者点菜单中的 前往-&gt;服务器），输入地址或者<code>ip</code>，使用<code>work</code>帐户登录，链接之后在命令行里的路径是：<code>/Volumes/work/</code></p>
<h3 id="win"><a href="#win" class="headerlink" title="win"></a>win</h3><p>使用运行命令(<code>win+R</code>)，输入<code>//IP</code>可打开，也可以打开<code>我的电脑</code>右击选择<code>添加一个网络位置</code>，输入<code>//IP/work</code>可映射到本地为一个盘符</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="http://zhaoyuqiang.blog.51cto.com/6328846/1214718" target="_blank" rel="external">权限</a></li>
<li><a href="http://blog.163.com/feng_qi_1314/blog/static/52820339201211693712365/" target="_blank" rel="external">samba配置</a></li>
</ul>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[用Yeomen搭建你的手脚架工具]]></title>
      <url>http://http://localhost:4000/2016/09/12/yeomen/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a> 可以帮助你快速开始一个新项目，你可以预先指定一些最佳实践，和实用工具来帮助你提高效率。它是一个生成器。<br>同时，它提供了一个良好的插件生态环境，开发者们能共享资源。开箱即用，一个generator能完整的生成一个工程或者是一个功能。</p>
<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><blockquote>
<p>目录结构</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">generator-baseconfig</div><div class="line">├── generators</div><div class="line">│   └── app</div><div class="line">│       ├── index.js</div><div class="line">│       └── templatesl</div><div class="line">│           ├── dir</div><div class="line">│           ├── .ackrc</div><div class="line">│           ├── .eslintrc.json</div><div class="line">│           ├── .gitignore</div><div class="line">│           └── package.json</div><div class="line">└── package.json</div></pre></td></tr></table></figure>
<p>yeoman-generator 需要加入package.json npm依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;generator-arch-karmaTest&quot;,</div><div class="line">  &quot;version&quot;: &quot;0.0.4&quot;,</div><div class="line">  &quot;description&quot;: &quot;karma单元测试环境&quot;,</div><div class="line">  &quot;repository&quot;: &#123;</div><div class="line">    &quot;type&quot;: &quot;git&quot;,</div><div class="line">    &quot;url&quot;: &quot;git@github.com:Alan110/generator-arch-karmaTest.git&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;files&quot;: [</div><div class="line">    &quot;generators/app&quot;</div><div class="line">  ],</div><div class="line">  &quot;homepage&quot;: &quot;git@github.com:Alan110/generator-arch-karmaTest&quot;,</div><div class="line">  &quot;keywords&quot;: [</div><div class="line">    &quot;yeoman-generator&quot;,</div><div class="line">    &quot;karmaTest&quot;</div><div class="line">  ],</div><div class="line">  &quot;main&quot;: &quot;index.js&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;author&quot;: &quot;Alan110&quot;,</div><div class="line">  &quot;license&quot;: &quot;MIT&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;chalk&quot;: &quot;^1.1.3&quot;,</div><div class="line">    &quot;yeoman-generator&quot;: &quot;^0.24.1&quot;,</div><div class="line">    &quot;yosay&quot;: &quot;^1.2.0&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>基本代码</p>
</blockquote>
<p>app/index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> yeoman = <span class="built_in">require</span>(<span class="string">'yeoman-generator'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 继承yeomen生成器基类</span></div><div class="line"><span class="keyword">var</span> baseconfig = yeoman.Base.extend(&#123;</div><div class="line">    <span class="attr">method1</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">this</span>.directory(<span class="string">'data'</span>, <span class="string">'data'</span>);				 <span class="comment">//拷贝目录</span></div><div class="line">        <span class="keyword">this</span>.copy(<span class="string">'package.json'</span>, <span class="string">'package.json'</span>);   <span class="comment">//拷贝文件</span></div><div class="line">        <span class="keyword">this</span>.log(<span class="string">'test'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = baseconfig;</div></pre></td></tr></table></figure>
<p>注意点 :</p>
<ul>
<li>项目目录名必须是generator-<em>**</em></li>
<li>生成文件要放在app/templates目录下</li>
<li>自行拷贝需要的文件/目录，执行yo name 的时候便会生成</li>
</ul>
<blockquote>
<p>本地运行</p>
</blockquote>
<p>在generator-** 目录下执行npm link 链接到全局模块，然后新建一个文件夹执行yo name</p>
<p><code>npm link</code><br><code>cd newdir &amp;&amp; yo name</code></p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-12/23544887.jpg" alt="pic alt"></p>
<blockquote>
<p>调试</p>
</blockquote>
<p>如果生成失败，可以执行yeomen自带的检测工具，根据提示修改环境问题</p>
<p><code>yo doctoer</code></p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-12/93505212.jpg" alt="pic alt"></p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote>
<p><a href="http://yeoman.io/authoring/running-context.html" target="_blank" rel="external">run loop</a></p>
</blockquote>
<p>可以理解每一个方法就是一个task，按顺序执行。<br>当执行yo example启动生成器时，它会沿着它的生命周期执行如下特定名称的函数，这些特定名称的函数会放进一个队列里面按顺序执行，如果功能函数不是特定的函数名称，如上面的method1，则放进另一个队列default按顺序执行。这些特定的函数名称有:</p>
<ul>
<li>initializing : 初始化阶段</li>
<li>prompting : 接受用户输入阶段</li>
<li>configuring : 保存配置信息和文件，如.editorconfig</li>
<li>default : 非特定的功能函数名称，如上面说到的method1</li>
<li>writing : 生成项目目录结构阶段</li>
<li>conflicts : 统一处理冲突，如要生成的文件已经存在是否覆盖等处理</li>
<li>install : 安装依赖阶段，如通过npm、bower</li>
<li>end : 生成器即将结束</li>
</ul>
<blockquote>
<p>私有方法</p>
</blockquote>
<p>使用下划线的方法不会加入run loop</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">generators.Base.extend(&#123;</div><div class="line">  <span class="attr">method1</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hey 1'</span>);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">_private_method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'private hey'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>继承父generators的方法不会加入run loop</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> MyBase = generators.Base.extend(&#123;</div><div class="line">  <span class="attr">helper</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'methods on the parent generator won\'t be called automatically'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = MyBase.extend(&#123;</div><div class="line">  <span class="attr">exec</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.helper();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>异步task</p>
</blockquote>
<p>某些情况需要阻塞run loop，拿到结果后继续执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">asyncTask: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> done = <span class="keyword">this</span>.async();</div><div class="line"></div><div class="line">  getUserEmail(<span class="function"><span class="keyword">function</span> (<span class="params">err, name</span>) </span>&#123;</div><div class="line">    done(err);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="修改已经存在的文件内容"><a href="#修改已经存在的文件内容" class="headerlink" title="修改已经存在的文件内容"></a><a href="http://yeoman.io/authoring/file-system.html" target="_blank" rel="external">修改已经存在的文件内容</a></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">this</span>.fs.copy(path, newPath, &#123;</div><div class="line">    <span class="attr">process</span>: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/* Any modification goes here. Note that contents is a Buffer object */</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> regEx = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'old string'</span>, <span class="string">'g'</span>);</div><div class="line">        <span class="keyword">var</span> newContent = content.toString().replace(regEx, <span class="string">'new string'</span>);</div><div class="line">        <span class="keyword">return</span> newContent;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="获取cli参数"><a href="#获取cli参数" class="headerlink" title="获取cli参数"></a><a href="http://yeoman.io/authoring/user-interactions.html" target="_blank" rel="external">获取cli参数</a></h2><p>yo baseconfig gulp</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">   initializing : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="keyword">this</span>.argument(<span class="string">'type'</span>, &#123;</div><div class="line">           <span class="attr">type</span>: <span class="built_in">String</span>,</div><div class="line">           <span class="attr">required</span>: <span class="literal">false</span>,  <span class="comment">// 可选，不强制</span></div><div class="line">           <span class="keyword">default</span>: <span class="string">'gulp'</span></div><div class="line">       &#125;);</div><div class="line">   &#125;,</div><div class="line"><span class="attr">myStart</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">       <span class="keyword">var</span> type = <span class="keyword">this</span>.options.type; <span class="comment">// 获取参数</span></div><div class="line">       <span class="keyword">this</span>.log(type || <span class="string">''</span>);</div><div class="line"></div><div class="line">       <span class="keyword">if</span> ([<span class="string">'gulp'</span>, <span class="string">'node'</span>].indexOf(type) == <span class="number">-1</span>) &#123;</div><div class="line">           <span class="keyword">this</span>.log(<span class="string">'没有指定或者非法参数，使用默认值 gulp'</span>)</div><div class="line">           type = <span class="keyword">this</span>.options.type = <span class="string">'gulp'</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">this</span>[<span class="string">'_gen_'</span> + type]();</div><div class="line"></div><div class="line">   &#125;,</div></pre></td></tr></table></figure>
<p>一定要在初始化的时候指定需要监听的参数，否则可能获取不到</p>
<hr>
<p>如果是这种参数<br>yo baseconfig –coffee</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">   initializing : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	 <span class="keyword">this</span>.option(<span class="string">'coffee'</span>); <span class="comment">//设置参数</span></div><div class="line">   &#125;,</div><div class="line"><span class="attr">myStart</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">	<span class="keyword">this</span>.log(<span class="keyword">this</span>.option(<span class="string">'coffee'</span>)); <span class="comment">//获取参数</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="与用户交互"><a href="#与用户交互" class="headerlink" title="与用户交互"></a>与用户交互</h2><p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-12/3780543.jpg" alt="pic alt"></p>
<blockquote>
<p><a href="https://github.com/SBoudrias/Inquirer.js#question" target="_blank" rel="external">Inquirer.js</a></p>
</blockquote>
<p>yeomen只用了Inquirer.js(在命令行下与用户交互的库).<br>prompt 接受一个question object 数组,返回promise</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// useage</span></div><div class="line">prompting: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prompt([&#123;</div><div class="line">      <span class="attr">type</span>    : <span class="string">'input'</span>,</div><div class="line">      <span class="attr">name</span>    : <span class="string">'name'</span>,</div><div class="line">      <span class="attr">message</span> : <span class="string">'Your project name'</span>,</div><div class="line">      <span class="attr">default</span> : <span class="keyword">this</span>.appname <span class="comment">// Default to current folder name</span></div><div class="line">      choices :</div><div class="line">      validate :</div><div class="line">      filter :</div><div class="line">      when :</div><div class="line">    &#125;, </div><div class="line">    &#123;</div><div class="line">      <span class="attr">type</span>    : <span class="string">'confirm'</span>,</div><div class="line">      <span class="attr">name</span>    : <span class="string">'cool'</span>,</div><div class="line">      <span class="attr">message</span> : <span class="string">'Would you like to enable the Cool feature?'</span></div><div class="line">    &#125;]).then(<span class="function"><span class="keyword">function</span> (<span class="params">answers</span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.log(<span class="string">'app name'</span>, answers.name);</div><div class="line">      <span class="keyword">this</span>.log(<span class="string">'cool feature'</span>, answers.cool);</div><div class="line">    &#125;.bind(<span class="keyword">this</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="和别的插件组合"><a href="#和别的插件组合" class="headerlink" title="和别的插件组合"></a>和别的插件组合</h2><h2 id="加载依赖-npm-brower"><a href="#加载依赖-npm-brower" class="headerlink" title="加载依赖(npm , brower)"></a><a href="http://yeoman.io/authoring/dependencies.html" target="_blank" rel="external">加载依赖(npm , brower)</a></h2><p>在install生命周期执行 this.npmInstall, 可以加载npm包,这很方便动态添加依赖，多个生成插件之间的配合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">install : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">this</span>.npmInstall([<span class="string">'babel-preset-es2015-rollup'</span>], &#123; <span class="string">'save-dev'</span>: <span class="literal">true</span> &#125;);</div><div class="line">     <span class="keyword">this</span>.npmInstall([<span class="string">'rollup-plugin-babel'</span>], &#123; <span class="string">'save-dev'</span>: <span class="literal">true</span> &#125;);</div><div class="line">     <span class="keyword">this</span>.npmInstall([<span class="string">'rollup-plugin-replace'</span>], &#123; <span class="string">'save-dev'</span>: <span class="literal">true</span> &#125;);</div><div class="line">     <span class="keyword">this</span>.npmInstall([<span class="string">'rollup-plugin-uglify'</span>], &#123; <span class="string">'save-dev'</span>: <span class="literal">true</span> &#125;);</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>有一些美化输出的插件。</p>
<ul>
<li><a href="https://github.com/chalk/chalk" target="_blank" rel="external">chalk</a>      //输出带颜色的文本</li>
<li><a href="https://github.com/yeoman/yosay" target="_blank" rel="external">yosay</a>     //输出一个图案</li>
</ul>
<h2 id="发布到npm"><a href="#发布到npm" class="headerlink" title="发布到npm"></a>发布到npm</h2><p>注册npmjs账号 <a href="https://www.npmjs.com/signup" target="_blank" rel="external">注册地址</a></p>
<p>在npmjs上登陆<br><code>npm config set registry http://registry.npmjs.org</code><br><code>npm adduser</code></p>
<p>很多人用的是淘宝镜像，此时必须是在npm官网上登陆,否则publish的时候会报错<br><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-12/15863496.jpg" alt=""></p>
<p>发布<br><code>npm publish .</code></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[美化你的vim]]></title>
      <url>http://http://localhost:4000/2016/09/11/nice-vim/</url>
      <content type="html"><![CDATA[<h2 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h2><p>将vim的光标改成插入模式下是竖线</p>
<blockquote>
<p>vim + tumx + item2 + macOS</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># .vimrc</div><div class="line">if exists(&apos;$ITERM_PROFILE&apos;)</div><div class="line">  if exists(&apos;$TMUX&apos;) </div><div class="line">    let &amp;t_SI = &quot;\&lt;Esc&gt;Ptmux;\&lt;Esc&gt;\&lt;Esc&gt;]50;CursorShape=1\x7\&lt;Esc&gt;\\&quot;</div><div class="line">    let &amp;t_SR = &quot;\&lt;Esc&gt;Ptmux;\&lt;Esc&gt;\&lt;Esc&gt;]50;CursorShape=2\x7\&lt;Esc&gt;\\&quot;</div><div class="line">    let &amp;t_EI = &quot;\&lt;Esc&gt;Ptmux;\&lt;Esc&gt;\&lt;Esc&gt;]50;CursorShape=0\x7\&lt;Esc&gt;\\&quot;</div><div class="line">  else</div><div class="line">    let &amp;t_SI = &quot;\&lt;Esc&gt;]50;CursorShape=1\x7&quot;</div><div class="line">    let &amp;t_SR = &quot;\&lt;Esc&gt;]50;CursorShape=2\x7&quot;</div><div class="line">    let &amp;t_EI = &quot;\&lt;Esc&gt;]50;CursorShape=0\x7&quot;</div><div class="line">  endif</div><div class="line">end</div></pre></td></tr></table></figure>
<blockquote>
<p>neovim + tmux </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># init.vim</div><div class="line">let $NVIM_TUI_ENABLE_CURSOR_SHAPE=1</div><div class="line"></div><div class="line"># tmux.conf</div><div class="line">set -g -a terminal-overrides &apos;,*:Ss=\E[%p1%d q:Se=\E[2 q&apos;</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://vim.wikia.com/wiki/Change_cursor_shape_in_different_modes" target="_blank" rel="external">其他环境下配置</a></p>
</blockquote>
<h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><blockquote>
<p><a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="external">airline</a></p>
</blockquote>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-11/88702776.jpg" alt="pic alt"></p>
<p>airline是一个状态栏美化插件。使用vundle安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Plugin &apos;vim-airline/vim-airline&apos;</div><div class="line">Plugin &apos;vim-airline/vim-airline-themes&apos;</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://powerline.readthedocs.io/en/latest/installation.html#pip-installation" target="_blank" rel="external">安装powerline</a> 使用符号字体</p>
</blockquote>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-11/63571441.jpg" alt=""></p>
<p>安装步骤:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. pip3 --user install powerline-status   // 安装powerline</div><div class="line"></div><div class="line">2. cd ./fonts &amp;&amp; ./install.sh             // 下载字体，安装字体</div><div class="line"></div><div class="line">3. let g:airline_powerline_fonts = 1      // 配置vimrc</div><div class="line"></div><div class="line">4. 设置终端字体为powerline字体</div></pre></td></tr></table></figure>
<p><a href="https://github.com/powerline/fonts" target="_blank" rel="external">powerline-fonts下载</a></p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-11/37487394.jpg" alt="pic alt"></p>
<p>注意点:</p>
<ul>
<li><p>pip安装必须要用 —user属性，不然会很卡, 这里貌似是有bug</p>
</li>
<li><p>设置终端字体，此处2个字体都要修改</p>
</li>
</ul>
<blockquote>
<p>切换airline主题</p>
</blockquote>
<p>一般主题也会自带airline主题，所以切换一下就行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:AirlineTheme &#123;theme-name&#125;</div></pre></td></tr></table></figure>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><blockquote>
<p><a href="https://github.com/morhetz/gruvbox" target="_blank" rel="external">gruvbox</a></p>
</blockquote>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-11/49414541.jpg" alt="pic alt"></p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Plug &apos;morhetz/gruvbox&apos; &quot;run :PlugInstall</div><div class="line">colorscheme gruvbox</div><div class="line"></div><div class="line">&quot;切换model</div><div class="line">set background=dark    &quot; Setting dark mode</div><div class="line">set background=light   &quot; Setting light mode</div></pre></td></tr></table></figure>
<p>配置:</p>
<ul>
<li><a href="https://github.com/morhetz/gruvbox/wiki/Usage" target="_blank" rel="external">usage</a></li>
<li><a href="https://github.com/morhetz/gruvbox/wiki/Usage" target="_blank" rel="external">configration</a></li>
</ul>
<blockquote>
<p><a href="https://github.com/nanotech/jellybeans.vim" target="_blank" rel="external">jellybeans</a></p>
</blockquote>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-11/40179806.jpg" alt="pic alt"></p>
]]></content>
      
        <categories>
            
            <category> vim </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[neovim]]></title>
      <url>http://http://localhost:4000/2016/09/07/neovim/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果说vim改变了我的生活，那么neovim改变了vim！vim毫无以为是伟大的文本编辑器。却也经不住时间的洗礼，以及人心的变迁。与现代编辑器相比，vim显得有些力不从心。虽然有那么多人热爱它，为它写了无数的插件，可当这些看似华丽的功能一个接着一个往vim本身纤细的身躯填充时，在我看来它失去了华彩。臃肿，卡顿，差强人意的体验，让人有些心寒。</p>
<p>众所周知，vim的门槛高，学习曲线陡峭。这很大程度上因为vim的许多默认配置是不人性化的，残留了太多历史问题。每个入门的新手，都要经历一遍折磨才能打造出稍微趁手的体验。</p>
<p>比较致命的问题是，vim的基因太差，老旧代码非常多，同时插件机制都是同步运行，当一个插件在运行时，也就锁定了UI。这给插件开发者带来非常大的限制。要么在非常短的时间内完成插件的运算逻辑，要么只能让用户承受不好的体验。然而比较搞笑的是，许多插件都支持异步执行，可vim的插件机制却不支持。</p>
<p>传闻vim的维护团队对于开发贡献者并不友好。很多贡献者的代码或者改进意见都被否决了。显得有些故步自封，我丝毫不怀疑如此下去，vim终将被替代。</p>
<p><a href="https://neovim.io/" target="_blank" rel="external">neovim</a><br>德国小伙，neovim作者，向vim作者提交了一个修改，但这个修改太大了，几乎重写了vim的底层。被vim的作者拒绝了。后来，它fork了vim的项目，开始了neovim的开发。它的意义就是让vim重获新生。让更多的人参与到vim的改进当中。</p>
<p>有消息称vim8.0也将支持异步机制，不知道这是不是受迫于neovim施加的压力而为。但结果总是vimer愿意看到的，希望心爱的编辑器越来越好。<br>最大的改变，添加异步执行的能力。</p>
<p>学习是有成本的，特别是强行扭转身体记忆。虽然有很多好用的编辑器，比如Atom，vscode。都是现代大火的编辑器，用过一段时间后还是回到vim。我仔细思考了下，不是因为我离不开vim，而是我离不开终端环境。vim之于终端是相辅相成的。</p>
<p>.config/init.vim</p>
<p>异步插件管理器</p>
<p>增强了默认配置。</p>
<h2 id="与vim的区别"><a href="#与vim的区别" class="headerlink" title="与vim的区别"></a>与vim的区别</h2><p>:sh 命令不再支持</p>
<h2 id="改变光标形状"><a href="#改变光标形状" class="headerlink" title="改变光标形状"></a>改变光标形状</h2><h2 id="开启true-color"><a href="#开启true-color" class="headerlink" title="开启true color"></a>开启true color</h2><h2 id="终端模拟器"><a href="#终端模拟器" class="headerlink" title="终端模拟器"></a>终端模拟器</h2><p>! cmd   没有颜色</p>
<h2 id="神级插件"><a href="#神级插件" class="headerlink" title="神级插件"></a>神级插件</h2><p>neomake</p>
<p>neoterm</p>
]]></content>
      
        <categories>
            
            <category> vim </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[使用karma管理测试框架]]></title>
      <url>http://http://localhost:4000/2016/08/30/IntegrateTest-karma/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>karma不是一个测试框架，也不是断言库，它只是开了一个http server，然后生成了一个包含测试代码，和测试框架的html页面。你可以使用任何你喜欢的测试框架。<br>karma是一个集成测试环境，管理我们的测试代码，测试依赖，让自动化测试变得简单。它能:</p>
<ul>
<li>在真实browser下运行测试</li>
<li>同时在多个浏览器下运行测试</li>
<li>watch测试文件变化，自动测试</li>
<li>终端执行测试</li>
<li>生成代码覆盖率报表</li>
<li>支持requirejs模块化测试</li>
</ul>
<p><img src="http://o99eh3ii0.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-31%20%E4%B8%8B%E5%8D%884.43.54.png" alt=""></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>进入工程目录<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo npm install karma --save-dev</div><div class="line">sudo npm install -g karma-cli</div></pre></td></tr></table></figure></p>
<p>需要安装全局cli命令工具。否则只能通过<code>./node_modules/karma/bin/karma start</code> 运行</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">karma init </div><div class="line">or karma init myconf.js // 命名配置文件</div></pre></td></tr></table></figure>
<p>进入交互配置界面。选择需要的测试框架，测试文件路径等等。完成后默认会在根目录生成karma.conf.js。如果没有配好可以手动修改该配置文件</p>
<p>配置文件里面的一些属性还可以通过命令行的方式设置,比如:<code>--browsers Chrome</code>。</p>
<p>这里只说明<strong>plugins</strong>和<strong>files</strong>2个字段 详细配置选项可以看看<a href="https://karma-runner.github.io/1.0/config/configuration-file.html" target="_blank" rel="external">官方文档</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">files: [</div><div class="line">    <span class="string">'lib/esl.js'</span>,</div><div class="line">    <span class="string">'lib/jquery.js'</span>,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">pattern</span>: <span class="string">'src/**/*.js'</span>,</div><div class="line">        <span class="attr">included</span>: <span class="literal">false</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">pattern</span>: <span class="string">'test/**/*.js'</span>,</div><div class="line">        <span class="attr">included</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">watched</span> : <span class="literal">false</span>,</div><div class="line">        <span class="attr">served</span> : <span class="literal">false</span></div><div class="line">    &#125;,</div><div class="line">],</div></pre></td></tr></table></figure>
<p>files引入的文件，会以script标签的方式直接插入页面中。每一个元素是字符串，也可以是一个对象，进行详细配置。</p>
<ul>
<li>pattern  寻找所有满足条件的文件</li>
<li>included 以<code>&lt;script&gt;</code>标签的形式插入文件(AMD下，需要设置为false) default: true</li>
<li>watched  当autoWatch=true 时，修改文件会自动重新载入  default: true</li>
<li>served   是否能被karma的webserver访问  default: true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">plugins:[</div><div class="line">    <span class="string">'karma-jasmine'</span>,</div><div class="line">    <span class="string">'karma-chrome-launcher'</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>karma默认会加载所有<strong>devDependencies</strong>字段里面，以karma-*开头的插件。也可以手动填写需要加载的插件。<br>如果写了此字段，就不会默认加载了。</p>
<h3 id="添加测试plugin"><a href="#添加测试plugin" class="headerlink" title="添加测试plugin"></a>添加测试plugin</h3><p>karma 的插件都是npm包，需要加入依赖。此处列出常用的几种配置方案</p>
<blockquote>
<p>jasmine + chrome</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">npm install karma-jasmine karma-chrome-launcher --save-dev</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// karma.conf.js配置</span></div><div class="line">frameworks: [<span class="string">'jasmine'</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p>mocha + chai  + chrome</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">npm install karma mocha chai  karma-mocha karma-chai  karma-chrome-launcher --save-dev</div><div class="line"></div><div class="line"><span class="comment">// karma.conf.js配置</span></div><div class="line">frameworks: [<span class="string">'mocha'</span>,<span class="string">'chai'</span>],</div></pre></td></tr></table></figure>
<blockquote>
<p>requirejs</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">npm install  requirejs karma-requirejs  --save-dev</div><div class="line"></div><div class="line"><span class="comment">// karma.conf.js配置</span></div><div class="line">frameworks: [<span class="string">'requirejs'</span>],   <span class="comment">// add this to list</span></div><div class="line"></div><div class="line">files: [</div><div class="line">    <span class="string">'test/mocha/test-main.js'</span>,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">pattern</span>: <span class="string">'output/*.js'</span>,</div><div class="line">        <span class="attr">included</span>: <span class="literal">false</span></div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">pattern</span>: <span class="string">'test/mocha/spec.js'</span>,</div><div class="line">        <span class="attr">included</span>: <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">],</div></pre></td></tr></table></figure>
<p>需要引入test-main.js。<br>注意由于要使用requirejs，那么所有的源文件和测试文件都要写成<strong>AMD模块</strong>,(以define包裹的模块)且file字段里面included设置为false，因为不需要注入了。通过requirejs载入。</p>
<p>test.main.js配置<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> allTestFiles = []</div><div class="line"><span class="keyword">var</span> TEST_REGEXP = <span class="regexp">/(spec|test)\.js$/i</span></div><div class="line"></div><div class="line"><span class="comment">// Get a list of all the test files to include</span></div><div class="line"><span class="built_in">Object</span>.keys(<span class="built_in">window</span>.__karma__.files).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (TEST_REGEXP.test(file)) &#123;</div><div class="line">    allTestFiles.push(file) <span class="comment">//匹配到的文件加入到依赖中。</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    </div><div class="line">    <span class="attr">baseUrl</span>: <span class="string">'/base/output'</span>,</div><div class="line"></div><div class="line">    <span class="comment">//测试文件会根据路径直接加载</span></div><div class="line">    deps: allTestFiles,</div><div class="line"></div><div class="line">    <span class="attr">callback</span>: <span class="built_in">window</span>.__karma__.start</div><div class="line">    </div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>test.main.js是用来配置requirejs的，其中baseUrl字段是设置查找模块的根路径. /base 相对于karma.conf.js的路径。</p>
<blockquote>
<p>代码覆盖率</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">npm install  karma-html-reporter karma-mocha-reporter karma-coverage  --save-dev</div><div class="line"></div><div class="line"><span class="comment">// karma.conf.js配置</span></div><div class="line">preprocessors: &#123;</div><div class="line">    <span class="string">'src/**/*.js'</span>: [<span class="string">'coverage'</span>] <span class="comment">// specific files to generate coverage reporter</span></div><div class="line">&#125;,</div><div class="line"><span class="attr">reporters</span>: [<span class="string">'coverage'</span>],   <span class="comment">// add this to list</span></div><div class="line">coverageReporter: &#123;        <span class="comment">// set dest of reporter</span></div><div class="line">    dir: <span class="string">'coverage/'</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>生成的html报表，可以在浏览器中打开，查看分支覆盖情况，函数覆盖情况</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-6/18392130.jpg" alt=""></p>
<p>点击每一个文件还能看到具体的是哪些语句没有执行到。我们要尽可能的减少红色的，黄色的尽可能覆盖,完善我们的测试用例</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-6/54203232.jpg" alt=""></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">karma start</div><div class="line">karma start my.conf.js</div></pre></td></tr></table></figure>
<p>默认会读取karma.conf.js文件，你也可以指定配置文件名。</p>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>在命令行下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">karma start karma.conf.js --browsers=Chrome --single-run=false --debug</div></pre></td></tr></table></figure>
<p>打开新弹出的chrome进程，点击debug进入调试页面。与浏览器的调试工具无异</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-6/20303741.jpg" alt=""></p>
<p>需要注意的，debug模式下，需要去掉coverage覆盖率，不然调试时会有很多覆盖率的代码，造成干扰。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">preprocessors: &#123;</div><div class="line">    <span class="string">'src/**/*.js'</span>: [<span class="string">'coverage'</span>] <span class="comment">// 去掉coverage</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者我们检测命令行是否有<code>--debug</code>，有则去掉coverage<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// debug时，去掉覆盖率报表</span></div><div class="line"><span class="keyword">var</span> preprocess = &#123;&#125;;</div><div class="line"><span class="keyword">if</span> (!(process.argv.join(<span class="string">','</span>).indexOf(<span class="string">'--debug'</span>) &gt; <span class="number">-1</span>)) &#123;</div><div class="line">    preprocess[<span class="string">'output/*.js'</span>] = <span class="string">'coverage'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">preprocessors: preprocess</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 前端自动化测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[前端自动化测试]]></title>
      <url>http://http://localhost:4000/2016/08/25/FETest/</url>
      <content type="html"><![CDATA[<h1 id="什么是自动化测试"><a href="#什么是自动化测试" class="headerlink" title="什么是自动化测试"></a>什么是自动化测试</h1><p>顾名思义，自动化测试就是让我们从手工的劳动中解放出来，让机器代我们去做一些事情。人力成本，总是有限的，况且难免出错。</p>
<p>自动化测试也是软件工程化的一部分。</p>
<h2 id="什么样的项目适合自动化测试"><a href="#什么样的项目适合自动化测试" class="headerlink" title="什么样的项目适合自动化测试"></a>什么样的项目适合自动化测试</h2><p>并不是所有的项目都适合自动化测试，甚至一个项目里面可能只有20%的代码适合自动化测试。<br>自动化测试不是神，它是有成本的，并不是说你做自动化测试就一定会有收益。</p>
<p>成本:</p>
<ul>
<li>测试环境的搭建和管理</li>
<li>测试环境的检查，监控和报警</li>
<li>测试代码的编译和测试构建</li>
<li>测试代码的静态检查和报警</li>
<li>测试用例的分发和执行</li>
<li>测试结果的保存与管理</li>
<li>测试报告的生成</li>
<li>测试优先级的建议</li>
</ul>
<p>解读：</p>
<ul>
<li>自动化的<strong>收益与项目迭代次数</strong>成正比</li>
<li>自动化收益可能为负数：即当<strong>自动化成本</strong>和<strong>维护成本</strong>比手动<strong>执行成本</strong>还高时</li>
<li>很多时候自动化成本并不比手动成本高，但是维护成本很高</li>
</ul>
<h3 id="适合的场景"><a href="#适合的场景" class="headerlink" title="适合的场景"></a>适合的场景</h3><p>让收益最大化原则，我们设想的合适场景是:</p>
<ul>
<li>以<strong>回归测试</strong>为主的项目。即需要长期做支持维护的产品。(迭代次数高)</li>
<li><strong>接口</strong>比较稳定的产品。(维护成本低)</li>
<li>手动测试特别费时费力，甚至无法达到测试目的的项目。比如<strong>压力测试</strong>，大数据或者大量重复数据测试，必须有自动化工具的支持。(手工成本高)</li>
<li><strong>覆盖性测试</strong>，避免遗漏边界情况(手工成本高)</li>
</ul>
<p><img src="http://o99eh3ii0.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-07%20%E4%B8%8B%E5%8D%883.44.52.png" alt="Alt Text"> </p>
<h2 id="前端自动化测试的难点"><a href="#前端自动化测试的难点" class="headerlink" title="前端自动化测试的难点"></a>前端自动化测试的难点</h2><p>近几年前端发展迅猛，前端越来越工程化，自动化。自动化测试是工程化中必不可少的一部分。<br>但是前端代码80%都是与GUI的相关的业务代码。从本质上来说，前端是一种特殊的<strong>GUI软件</strong>。API测试方法论在测试GUI时并不能解决所有问题。GUI测试的成本非常高:</p>
<ol>
<li><p>它的输入输出不明确,不好写case</p>
</li>
<li><p>它的迭代速度很快，case的维护成本非常高。</p>
</li>
</ol>
<p>所以针对那相对稳定的20%,我们可以采用API测试，以及模拟测试。而剩下的80%，主要还是靠人力测试。</p>
<h2 id="针对80-的测试"><a href="#针对80-的测试" class="headerlink" title="针对80%的测试"></a>针对80%的测试</h2><p>针对这部分的自动化测试，更多的是辅助测试。缩小测试范围，最后由人工测试。</p>
<h4 id="1、页面差异监控"><a href="#1、页面差异监控" class="headerlink" title="1、页面差异监控"></a>1、页面差异监控</h4><p>基于dom树的diff，原理是利用phantomjs等无头浏览器，访问页面，遍历整个dom树，    构造出一个json结构。每次diff这个json，来对比差异。用于缩小回归范围。</p>
<h2 id="针对20-的测试"><a href="#针对20-的测试" class="headerlink" title="针对20%的测试"></a>针对20%的测试</h2><h4 id="1、单测"><a href="#1、单测" class="headerlink" title="1、单测"></a>1、单测</h4><hr>
<h4 id="2、行为测试"><a href="#2、行为测试" class="headerlink" title="2、行为测试"></a>2、行为测试</h4><h4 id="3、集成方案"><a href="#3、集成方案" class="headerlink" title="3、集成方案"></a>3、集成方案</h4><blockquote>
<p><a href="https://www.npmjs.com/package/karma" target="_blank" rel="external">karma</a></p>
</blockquote>
<p>前端集成测试框架，本身不提供测试库，支持主流的测试框架。管理依赖，复杂测试。支持生成代码覆盖率报表。</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-31%20%E4%B8%8B%E5%8D%884.43.54.png" alt=""></p>
<blockquote>
<p>总结：强烈推荐，管理各种依赖，测试框架。专注于测试本身</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 前端自动化测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[前端行为测试]]></title>
      <url>http://http://localhost:4000/2016/08/25/behaviorTest/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.npmjs.com/package/karma" target="_blank" rel="external">phantomjs</a></p>
</blockquote>
<p>PhantomJS 是一个基于 WebKit的无头浏览器。原生支持各种web标准:  DOM 处理, CSS 选择器, JSON, Canvas, 和 SVG 。 PhantomJS 可以用于 页面自动化 ， 网络监测 ， 网页截屏 ，以及 无界面测试 等。</p>
<p>所以，可以把phantomjs就想象成一个浏览器，它提供了很多浏览器级别的api，供开发者使用。它可以注入本地，或者远程js代码到目标页面，对于自动化模拟用户操作很有帮助。</p>
<p>可以在目标页面沙箱执行js代码。</p>
<p>可以与断言库结合，利用console报表与onMessage事件通信，在真实环境下跑单侧</p>
<blockquote>
<p>总结：灵活性高，可以做爬虫，可以做测试，可以做监控，但对代码质量要求也高，同步，异步代码组织困难。</p>
</blockquote>
<hr>
<blockquote>
<p><a href="http://docs.casperjs.org/en/latest/installation.html" target="_blank" rel="external">casperjs</a></p>
</blockquote>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-9-9/35599761.jpg" alt=""><br>casperjs是基于phantomjs封装的一个web应用测试框架。</p>
<p>它封装了phantomjs的api，并提供了一套高级的测试api,以及断言库。开发者不用自己去维护phantomjs的异步，同步代码，执行顺序等问题。更专注于浏览器测试本身。</p>
<p>可以支持单元测试和浏览器测试,但是不支持其他的断言库</p>
<blockquote>
<p>总结：web测试的最佳选择，简单，完整。</p>
</blockquote>
<hr>
<blockquote>
<p>slimerjs</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 前端自动化测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[前端单元测试]]></title>
      <url>http://http://localhost:4000/2016/08/25/unitTest-md/</url>
      <content type="html"><![CDATA[<h2 id="单元测试风格"><a href="#单元测试风格" class="headerlink" title="单元测试风格"></a>单元测试风格</h2><p>BDD TDD</p>
<h2 id="断言库"><a href="#断言库" class="headerlink" title="断言库"></a>断言库</h2><blockquote>
<p><a href="http://jasmine.github.io/edge/introduction.html" target="_blank" rel="external">jasmine</a></p>
</blockquote>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-8-28/59843772.jpg" alt=""><br>jasmine 是一个bdd驱动的测试框架,自带<strong>断言库</strong><br>支持部分函数spy，stub，mock的能力<br>支持异步测试</p>
<blockquote>
<p>总结: 在浏览器上做单元测试是比较好的，但是与别的工具整合有些麻烦，需要自行实现reporter</p>
</blockquote>
<hr>
<blockquote>
<p><a href="http://mochajs.org/" target="_blank" rel="external">mocha</a></p>
</blockquote>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//16-8-28/96121519.jpg" alt=""><br>mocha 是一个功能丰富的js测试框架，可以有BDD和TDD的测试风格。<br>支持nodejs,浏览器端测试<br>支持异步测试<br>支持任意断言库</p>
<blockquote>
<p>总结: <strong>功能完善，可配置性强,与其他工具整合方便，也需要自实现报表</strong></p>
</blockquote>
<h2 id="sinon-js-增强测试手段"><a href="#sinon-js-增强测试手段" class="headerlink" title="sinon.js 增强测试手段"></a>sinon.js 增强测试手段</h2><p>为了更好的测试，减少依赖，sinon.js提供一些增强测试手段或者说概念。</p>
<blockquote>
<p><a href="http://sinonjs.org/docs/" target="_blank" rel="external">spy</a></p>
</blockquote>
<p>A test spy is a function that records arguments, return value, the value of this and exception thrown (if any) for all its calls</p>
<p>spy是一个间谍函数，它用于测试函数callback, 或者对象的某个方法。就像间谍，他还是他，只不过他会向我们汇报”敏感信息”。<br>spy可以告诉我们函数调用的参数，返回值，this对象，和它被调用的次数，抛出的异常等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">setUp</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        sinon.spy(jQuery, <span class="string">"ajax"</span>);</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="attr">tearDown</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        jQuery.ajax.restore(); <span class="comment">// Unwraps the spy</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="string">"test should inspect jQuery.getJSON's usage of jQuery.ajax"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        jQuery.getJSON(<span class="string">"/some/resource"</span>);</div><div class="line"></div><div class="line">        assert(jQuery.ajax.calledOnce);</div><div class="line">        assertEquals(<span class="string">"/some/resource"</span>, jQuery.ajax.getCall(<span class="number">0</span>).args[<span class="number">0</span>].url);</div><div class="line">        assertEquals(<span class="string">"json"</span>, jQuery.ajax.getCall(<span class="number">0</span>).args[<span class="number">0</span>].dataType);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://sinonjs.org/docs/#stubs" target="_blank" rel="external">stub</a> </p>
</blockquote>
<p>stub是一个依赖的替代函数，当我们测试的模块依赖别的API接口时，就可以使用stub来代替, 预先定义好行为。<br>stub本质上也是一个spy，拥有spy完整的能力。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">it(<span class="string">"returns the return value from the original function"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> callback = sinon.stub().returns(<span class="number">42</span>);</div><div class="line">    <span class="keyword">var</span> proxy = once(callback);</div><div class="line"></div><div class="line">    assert.equals(proxy(), <span class="number">42</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>mock</p>
<p>fake</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var xhr, requests;</div><div class="line"></div><div class="line">before(function () &#123;</div><div class="line">    xhr = sinon.useFakeXMLHttpRequest();</div><div class="line">    requests = [];</div><div class="line">    xhr.onCreate = function (req) &#123; requests.push(req); &#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">after(function () &#123;</div><div class="line">    // Like before we must clean up when tampering with globals.</div><div class="line">    xhr.restore();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">it(&quot;makes a GET request for todo items&quot;, function () &#123;</div><div class="line">    getTodos(42, sinon.spy());</div><div class="line"></div><div class="line">    assert.equals(requests.length, 1);</div><div class="line">    assert.match(requests[0].url, &quot;/todo/42/items&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端自动化测试 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[json字符串中带json字符串]]></title>
      <url>http://http://localhost:4000/2016/08/23/js-escape/</url>
      <content type="html"><![CDATA[<h2 id="什么是转义字符"><a href="#什么是转义字符" class="headerlink" title="什么是转义字符"></a>什么是转义字符</h2><p>转义字符是一些特殊的字符,可以用反斜杠在文本字符串中插入省略号、换行符、引号和其他特殊字符。<br>比如这种 :</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> txt=<span class="string">"We are the so-called "</span>Vikings<span class="string">" from the north."</span></div><div class="line"><span class="built_in">document</span>.write(txt)</div></pre></td></tr></table></figure>
<blockquote>
<p>转义字符是有一定意义的，在赋给一个变量后，会立即转为相应的字符。</p>
</blockquote>
<p><img src="http://o99eh3ii0.bkt.clouddn.com/16-8-23/21328790.jpg" alt=""></p>
<blockquote>
<p>所以看到转义，可以直接把他替换为相应的字符来理解。上图的转义”号，三个”号就报错了。</p>
</blockquote>
<h2 id="JavaScript的转义字符"><a href="#JavaScript的转义字符" class="headerlink" title="JavaScript的转义字符"></a>JavaScript的转义字符</h2><p><img src="http://o99eh3ii0.bkt.clouddn.com/16-8-23/8874483.jpg"></p>
<h2 id="传递转义"><a href="#传递转义" class="headerlink" title="传递转义"></a>传递转义</h2><p>那如何传递转义呢？</p>
<p>也就是我踩的这个坑。json字符串中的一个属性是json字符串。</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-21/26026330.jpg" alt="Alt Text"> </p>
<p>当我最后再parse回去的时候，就报错了。通过前文，可知我们可以将\” 直接看成 “ , 就可以发现有明显语法错误了。</p>
<p>这里是需要保留转义的能力，而不是立即转换。 所以需要双转义，将\本身也转义了，作为字符串的一部分传递给JSON.parse。</p>
<p><img src="http://o99eh3ii0.bkt.clouddn.com//public/16-11-21/48849402.jpg" alt="Alt Text"> </p>
]]></content>
      
        <categories>
            
            <category> 踩过的坑 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[gulp搭建构建系统]]></title>
      <url>http://http://localhost:4000/2016/08/21/gulp/</url>
      <content type="html"><![CDATA[<p>前端的3大缺陷能力</p>
<ul>
<li><p>资源定位</p>
</li>
<li><p>内容嵌入</p>
</li>
<li><p>声明依赖</p>
</li>
</ul>
<p>整个构建过程是输入-&gt;输出，<br>要么就是拆分完整的输入到输出流程,互相重叠不大的task，要么是一次性完整输入，然后筛选做不同处理，然后一次性完整输出</p>
<h2 id="单文件处理"><a href="#单文件处理" class="headerlink" title="单文件处理"></a>单文件处理</h2><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>以html页面为单位，打包资源，并添加md5</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line">gulp.task(<span class="string">'ref'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    gulp.src(<span class="string">'unittest/mocha/index.html'</span>)</div><div class="line">        .pipe(useref())</div><div class="line">        .pipe(gulpif(<span class="string">'*.js'</span>, rev()))</div><div class="line">        .pipe(revReplace())</div><div class="line">        .pipe(gulp.dest(distPath))</div><div class="line">        .pipe(rev.manifest())</div><div class="line">        .pipe(gulp.dest(revPath));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>将打包后的文件变成单文件，然后做单文件处理</p>
<p>被打包的文件应该自行做单文件处理，和资源定位</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>gulp的任务是异步执行的不能保证顺序，使用gulp-sequence同步执行任务</li>
</ol>
<ul>
<li><p>dest不能重命名，使用gulp-rename解决</p>
</li>
<li><p>最好分成开发配置，上线配置2分，互不干扰</p>
</li>
<li><p>插件太多，每个都要require很麻烦，使用gulp-load-plugins解决，$.pluginName , 驼峰命名</p>
</li>
</ul>
<ol>
<li>API</li>
</ol>
<p>gulp.src</p>
<p>gulp.dest</p>
]]></content>
      
        <categories>
            
            <category> 构建工具 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[fis3 入门解析]]></title>
      <url>http://http://localhost:4000/2016/08/18/fis3/</url>
      <content type="html"><![CDATA[<p>fis3虽然入门简单，可是真的要上手，还是有点难度的。源于有些配置含混不清。</p>
<p>理解fis3的一些概念是很有帮助的</p>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>fis3尽可能不会改变源码，它会把源文件目录，原样输出。这就有个问题，即所有文件都是有输出的。正常情况下，这没有什么问题，而且节省很多的路径配置工作，但是在做SPA，需要合并输出的场景下，这个就显得很恶心了。fis3可以打包合并。但是不是覆盖源文件，而且新增一个副本。</p>
<p>你可能会想讲打包的文件设置为release:false，不让它输出就行了。然而实际情况是，不输出便无法打包。</p>
<h2 id="忽略打包过的文件"><a href="#忽略打包过的文件" class="headerlink" title="忽略打包过的文件"></a>忽略打包过的文件</h2><p>fis3-skip-packed    这个插件是可以的，可以去看看怎么实现的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">fis.media(<span class="string">'dev'</span>).match(<span class="string">'**'</span>, &#123;</div><div class="line">  <span class="attr">deploy</span>: [</div><div class="line">    fis.plugin(<span class="string">'skip-packed'</span>, &#123;</div><div class="line">      <span class="comment">// 配置项</span></div><div class="line">      <span class="comment">//'skipPackedToAIO' : false,</span></div><div class="line"><span class="comment">//      'skipPackedToPkg' : false</span></div><div class="line">    &#125;),</div><div class="line"></div><div class="line">    fis.plugin(<span class="string">'local-deliver'</span>, &#123;</div><div class="line">      <span class="attr">to</span>: <span class="string">'/Users/alan/.fis3-tmp/www'</span></div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>注意，配置了deploy选项，就会覆盖默认的deploy路径，默认是发布到本地server的路径，所以这里要手动设置一下</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>fis3默认不提供模块化框架，它所谓的模块化方案是说你以模块化(requirejs ,commonjs)的语法来写模块, fis会根据文件路径重新定义模块名, 然而我觉得这个很鸡肋啊，我们本来就不提倡命名模块，推荐模块名由实际服务器端文件路径决定。fis这么做感觉有点多此一举。</p>
<p>异步模块化方案有一个相对路径的概念,都是baseUrl + path ，模块引用使用相对路径。这样放到服务器上就能访问。</p>
<p>fis的inline功能很好用，但是不推荐用来做模块化,要限制它的使用。我认为它的应用场景应该只在html文件中，嵌入css，js源码。其他场景都应该由语言自身的模块化能力来解决</p>
<h3 id="moduleId-的注意点"><a href="#moduleId-的注意点" class="headerlink" title="moduleId 的注意点"></a>moduleId 的注意点</h3><p>moduleId的名字是没有.js后缀的，千万注意，否则会require不到。release的文件名是可以没有.js后缀的，会自动加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">fis.media(&apos;dev&apos;).match(&quot;/src/(*).js&quot;,&#123;</div><div class="line">    release : &quot;$1&quot;,</div><div class="line">    isMod : true,</div><div class="line">    moduleId : &apos;$1&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><p>可以使用media来设置不同的发布配置，<br>使用环境变量来做同media下的细分配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var process = require(&apos;process&apos;);</div><div class="line">if(process.env.fisv == &apos;xx&apos;)&#123;</div><div class="line">    fis.media(&apos;dev&apos;).match(&apos;*.js&apos;,&#123;</div><div class="line">        1...</div><div class="line">    &#125;);</div><div class="line">&#125;else&#123;</div><div class="line">    fis.media(&apos;dev&apos;).match(&apos;*.js&apos;,&#123;</div><div class="line">        2...</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">调用</div><div class="line"></div><div class="line">fisv=xx fis3 relase dev</div><div class="line"></div><div class="line">fisv=xxx 只会在当次命令下生效</div></pre></td></tr></table></figure></p>
<p>注意，process.env.fisv 只能在外层fis语法里面拿到，在内层函数里面是拿不到的。比如在:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fis.match(&apos;*.js&apos;,&#123;</div><div class="line">    preprocessor:function()&#123;</div><div class="line">       process.env.fisv  // 拿不到 </div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>fis默认对文件有编译换成，如果文件没有改变，下一次编译会直接走缓存，使用环境变量的方式，可能不同次编译走的fis配置语句不同，所以要去掉文件的缓存<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fis.match(&apos;*.js&apos;,&#123;</div><div class="line">    useCatche : false</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h2 id="构件流程"><a href="#构件流程" class="headerlink" title="构件流程"></a>构件流程</h2>]]></content>
      
        <categories>
            
            <category> 构建工具 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[极致编程，我最爱的vim]]></title>
      <url>http://http://localhost:4000/2016/08/16/vim/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vim是有毒的!</p>
<p>vim是有毒的!</p>
<p>vim是有毒的!</p>
<p>vim的定位,它只是一个编辑器.适合文件修改与小工程的开发.如果希望它变得像ide一样,那需要很多的工具配合.不会做就不会死,对它偏爱的人偏偏要作!,而且作得极致.就像咱们中国是走的中国特色社会主义道路一样，vim也应该有它属于每个人独特的道路.</p>
<p>你可以让它大而全，也可以让他小而精美。vim是一块精石,需要他的主人不停的对它打磨，才能变成宝玉。没有毅力之人，或是对它的爱不够深切，都将无法令之完全绽放光芒。本人不才,我用了半年的时间来适应它的按键布局,它的模式理念.又花了一年学着怎样怎样给他装插件,怎样高效的用它编辑,怎么让它融入到我的指尖.其中无数的爱与恨伴我度过了多少日夜,敲过了多少代码.好几回我都想离她而去,然而用别的编辑器一段时间,我又无法忘怀她的一切,琢磨着怎样让她焕发新生.于是又毅然回归.或许你会说我傻,可是她真的融入到了我的工作生活,我戒不掉了.</p>
<p>前期使用vim有一个要点是，要动脑子。完成一个操作，有很多种方式，要选择最合适方式才最高效。这往往很不容易，因为还要在写作的过程中动脑子想用什么组合快捷键，是很让人烦的，往往最后就演变成不停的jjjj,kkkk，效率奇低，最后内伤而逃。但如果你坚持下来了，把这些best pricite练成了身体记忆，你也就学会了vim这套武功秘籍。</p>
<p>我为什么要学vim？</p>
<ul>
<li>它真的能让我装逼</li>
<li>它给我足够的空间去创造。</li>
<li>一劳永逸，再也不需要学别的编辑器了。</li>
</ul>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>homebrew 安装</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">brew install vim  --with-lua --with-python</div><div class="line">brew install macvim  --with-lua --with-python   // gui版</div></pre></td></tr></table></figure>
<blockquote>
<p>源码安装</p>
</blockquote>
<p>为什么要源码安装？<br>这样才能保证是最新的，而且能够保证对各种特性插件的支持，比如一些对lua，python依赖的插件。</p>
<p>下载源码<br><a href="https://github.com/vim/vim" target="_blank" rel="external">https://github.com/vim/vim</a><br>可以看下各个环境的安装说明，src/INSTALL文件</p>
<p>配置编译选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./configure --with-features=huge --enable-rubyinterp --enable-pythoninterp --with-python-config-dir=/usr/lib/python2.7/config-i386-linux-gnu/ --enable-perlinterp  --enable-cscope --enable-luainterp --enable-perlinterp --enable-multibyte --prefix=/usr/local/bin/</div></pre></td></tr></table></figure>
<ul>
<li>–with-features=huge：支持最大特性</li>
<li>–enable-rubyinterp：启用Vim对ruby编写的插件的支持</li>
<li>–enable-pythoninterp：启用Vim对python编写的插件的支持</li>
<li>–enable-luainterp：启用Vim对lua编写的插件的支持</li>
<li>–enable-perlinterp：启用Vim对perl编写的插件的支持</li>
<li>–enable-multibyte：多字节支持 可以在Vim中输入中文</li>
<li>–enable-cscope：Vim对cscope支持</li>
<li>–enable-gui=gtk2：gtk2支持,也可以使用gnome，表示生成gvim</li>
<li>–with-python-config-dir=/usr/lib/python2.7/config-i386-linux-gnu/ 指定 python 路径</li>
<li>–prefix=/usr/local/bin/：编译安装路径</li>
</ul>
<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>这部分教程网上多如牛毛，我也就不多说了，同时vim的快捷键多如牛毛，也不好一一说明。<br>在网上淘了如下几种入门方式。总之学会看文档是关键.</p>
<blockquote>
<p>自带的vimtutor</p>
<p>游戏<a href="http://vim-adventures.com/" target="_blank" rel="external">vim大冒险</a></p>
</blockquote>
<p><img src="http://feihu.me/img/posts/vim-adventures.jpg" alt=""></p>
<blockquote>
<p>vim速记图</p>
</blockquote>
<p><img src="http://o99eh3ii0.bkt.clouddn.com/vim-cmd.png" alt=""></p>
<blockquote>
<p>vim自带文档说明</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:help       // 完整文档</div><div class="line">:h buffer   // 查看某一部分的文档</div></pre></td></tr></table></figure>
<p>看不惯英文可以去装中文版</p>
<h3 id="常用特性"><a href="#常用特性" class="headerlink" title="常用特性"></a>常用特性</h3><h4 id="text-object"><a href="#text-object" class="headerlink" title="text object"></a>text object</h4><blockquote>
<p>:help text-objects</p>
</blockquote>
<ul>
<li><action>i<object> 作用于对象内部，不包括边界</object></action></li>
<li><action>a<object> 作用于整个对象，括边界</object></action></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">ci&apos;   改变&apos;中的内容</div><div class="line">ca&apos;   改变&apos;中的内容（包括&quot;&apos;&quot;号）</div><div class="line">di[   删除[中的内容</div><div class="line">da[   ...</div><div class="line">&gt;i&#123;   缩进&#123;中的代码</div><div class="line">&gt;a&#123;   ...</div></pre></td></tr></table></figure>
<h4 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h4><h4 id="tab"><a href="#tab" class="headerlink" title="tab"></a>tab</h4><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>怎样才算是一个好的编辑器？我认为有3个维度:</p>
<ul>
<li>快速移动</li>
<li>高效编辑</li>
<li>扩展定制</li>
</ul>
<p>为什么键盘比鼠标效率高？因为在熟练的情况下，它更准确，更少的误操作。身体记忆，无需思考。vim更是将键盘的优势极度放大，设置了3种模式，各司其职，快捷键无数。就像是一个军火库，什么装备都有，不过你非要拿大炮去打一个小毛贼，费时费力，大材小用,我也无话可说。这考验的是你的经验和那一点灵气。</p>
<h3 id="快速移动"><a href="#快速移动" class="headerlink" title="快速移动"></a>快速移动</h3><p>能精确而快速的定位到你要编辑的地方，这是用好vim的一个诀窍。</p>
<p>就像前面说的，很多人可能只会用j，k，h，l几个最基础的方向键，无疑编辑体验是痛苦的。这些人并没有学到vim的精髓。</p>
<h4 id="多种插入方式"><a href="#多种插入方式" class="headerlink" title="多种插入方式"></a>多种插入方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">A   // 当前行后插入</div><div class="line">I   // 当前行前插入</div><div class="line">o   // 下一行插入</div><div class="line">O   // 上一行插入</div></pre></td></tr></table></figure>
<h4 id="横向行内搜索"><a href="#横向行内搜索" class="headerlink" title="横向行内搜索"></a>横向行内搜索</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">f&#123;字母&#125; //  横向搜索第一个出现的字母, 此时按; ，搜寻下一个该字母</div></pre></td></tr></table></figure>
<p>这个是很常用的，快速定位到行内的某个字母.</p>
<h4 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h4><h4 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ctrl + d    // 光标向后翻半屏</div><div class="line">ctrl + e    // 屏幕向下翻一行</div><div class="line">ctrl + f    // 光标向后翻一屏</div><div class="line">ctrl + b    // 光标向前翻一屏</div><div class="line"></div><div class="line">H   //  将光标置于最上面</div><div class="line">L   //  将光标置于最下面</div><div class="line">M   //  将光标置于中间面</div><div class="line">zt  //  将光标当前行置为屏幕顶端</div><div class="line">zb  //  将光标当前行置为屏幕底端</div><div class="line">zz  //  将光标当前行置为屏幕中间</div></pre></td></tr></table></figure>
<p>翻页在我们浏览的时候是很常用的，ctrl + f/b 会使得光标和屏幕都移动，不好预测结果会在哪里，体验糟糕。推荐使用zt系列的方式翻页，我们可以预测翻页后的结果，体验好很多，也不用频繁按键。</p>
<h4 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h4><h4 id="鼠标模式"><a href="#鼠标模式" class="headerlink" title="鼠标模式"></a>鼠标模式</h4><h4 id="插件easyMotion"><a href="#插件easyMotion" class="headerlink" title="插件easyMotion"></a>插件easyMotion</h4><h3 id="高效编辑"><a href="#高效编辑" class="headerlink" title="高效编辑"></a>高效编辑</h3><h3 id="map-按键映射"><a href="#map-按键映射" class="headerlink" title="map 按键映射"></a>map 按键映射</h3><p><img src="http://o99eh3ii0.bkt.clouddn.com/vim_map.jpg" alt="pic alt"></p>
<h3 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h3><ul>
<li><p>推荐主题</p>
</li>
<li><p>光标美化</p>
</li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul>
<li><p>减少normal，insert模式之间的切换</p>
</li>
<li><p>善用重复功能键</p>
</li>
</ul>
<h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><ul>
<li>插件安装</li>
</ul>
<p>bundle</p>
]]></content>
      
        <categories>
            
            <category> vim </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo个性化配置(进阶篇)]]></title>
      <url>http://http://localhost:4000/2016/08/14/hexo-master/</url>
      <content type="html"><![CDATA[<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><blockquote>
<p>需要注意的是，Hexo 3.2 版本不允许配置文件中存在重复的选项设置。 因此，最好检查下 站点配置文件 中是否有存在上述同名的配置。 如果存在，请将两者配置在一起。</p>
</blockquote>
<h3 id="设置菜单对应的中文"><a href="#设置菜单对应的中文" class="headerlink" title="设置菜单对应的中文"></a>设置菜单对应的中文</h3><p><a href="http://theme-next.iissnan.com/getting-started.html#menu-settings" target="_blank" rel="external">http://theme-next.iissnan.com/getting-started.html#menu-settings</a></p>
<h3 id="首页显示文章列表"><a href="#首页显示文章列表" class="headerlink" title="首页显示文章列表"></a>首页显示文章列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;% set display_toc = `is_post and` theme.toc.enable %&#125;</div><div class="line">&#123;% set display_toc = theme.toc.enable %&#125;</div></pre></td></tr></table></figure>
<h3 id="如何设置页面文章的篇数？"><a href="#如何设置页面文章的篇数？" class="headerlink" title="如何设置页面文章的篇数？"></a>如何设置页面文章的篇数？</h3><blockquote>
<p>hexo可以设置首页,归档,tag的文章篇数,不过需要安装hexo的插件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install --save hexo-generator-index</div><div class="line">npm install --save hexo-generator-archive</div><div class="line">npm install --save hexo-generator-tag</div></pre></td></tr></table></figure>
<p>在根目录的_config.yml中配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><div class="line"><span class="attr">index_generator:</span></div><div class="line"><span class="attr">  per_page:</span> <span class="number">5</span></div><div class="line"></div><div class="line"><span class="attr">archive_generator:</span></div><div class="line"><span class="attr">  per_page:</span> <span class="number">20</span></div><div class="line"><span class="attr">  yearly:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  monthly:</span> <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="attr">tag_generator:</span></div><div class="line"><span class="attr">  per_page:</span> <span class="number">10</span></div></pre></td></tr></table></figure>
<h2 id="next主题自定义"><a href="#next主题自定义" class="headerlink" title="next主题自定义"></a>next主题自定义</h2><ul>
<li>看下官方文档</li>
</ul>
<p>包括了</p>
<p>代码高亮<br>页面3种样式布局</p>
<ul>
<li>优化动画效果</li>
</ul>
<blockquote>
<p>默认的动画太慢了,先是logo,然后是menu,postlist,sliderbar,依次动画执行.对于有强迫症的人来说,这个真心受不了.曾一度关闭了动画.设置<code>use_motion:false</code>. 后来想想还是觉得给页面增加一点灵气比较好.就有了修改主题代码的打算.</p>
</blockquote>
<p>next与页面动画相关的代码是在/source/js/src/motion.js文件里. 乍一看,真是云里雾里,不知道如何下手.个人认为代码结构有些混乱,吐槽一下.平静一下心情,仔细找了找.发现了这2段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">hasElement($subtitle) &amp;&amp; sequence.push(&#123;</div><div class="line">  <span class="attr">e</span>: $subtitle,</div><div class="line">  <span class="attr">p</span>: &#123;<span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">top</span>: <span class="number">0</span>&#125;,</div><div class="line">  <span class="attr">o</span>: &#123;<span class="attr">duration</span>: <span class="number">200</span>&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">$.Velocity.RunSequence(sequence);</div></pre></td></tr></table></figure>
<p>顿时发现与jquery的动画调用有些类似,无非是设置起点,终点属性,然后调用.只是不知作者是用的什么库.baidu了一下,原来是用的<code>Velocityjs</code>动画库.翻了一下API,明白了,这2句话是说,创建一个array,每一个元素是一个动画帧,其中有具体的动画描述属性.运行时会按顺序一个接着一个运行,说白了就是一个动画队列.</p>
<p>明白了核心代码,情况就明朗多了. 不过又发现一个让我迷糊的点.看看这段代码摘要,部分代码我已删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">NexT.motion.middleWares =  &#123;</div><div class="line">  <span class="attr">logo</span>: <span class="function"><span class="keyword">function</span> (<span class="params">integrator</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sequence = [];</div><div class="line">    <span class="keyword">var</span> $brand = $(<span class="string">'.brand'</span>);</div><div class="line">    ....</div><div class="line">    if (sequence.length &gt; <span class="number">0</span>) &#123;</div><div class="line">      sequence[sequence.length - <span class="number">1</span>].o.complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        integrator.next();</div><div class="line">      &#125;;</div><div class="line">      $.Velocity.RunSequence(sequence);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      integrator.next();</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">menu</span>: <span class="function"><span class="keyword">function</span> (<span class="params">integrator</span>) </span>&#123;</div><div class="line">    $(<span class="string">'.menu-item'</span>).velocity(<span class="string">'transition.slideDownIn'</span>, &#123;</div><div class="line">      <span class="attr">display</span>: <span class="literal">null</span>,</div><div class="line">      <span class="attr">duration</span>: <span class="number">200</span>,</div><div class="line">      <span class="attr">complete</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        integrator.next();</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">postList</span>: <span class="function"><span class="keyword">function</span> (<span class="params">integrator</span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">postMotion</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> postMotionOptions = <span class="built_in">window</span>.postMotionOptions || &#123;</div><div class="line">          <span class="attr">stagger</span>: <span class="number">100</span>,</div><div class="line">          <span class="attr">drag</span>: <span class="literal">true</span></div><div class="line">        &#125;;</div><div class="line">      postMotionOptions.complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="string">`integrator.next();`</span></div><div class="line">      &#125;;</div><div class="line"></div><div class="line">      $post.velocity(<span class="string">'transition.slideDownIn'</span>, postMotionOptions);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">sidebar</span>: <span class="function"><span class="keyword">function</span> (<span class="params">integrator</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (CONFIG.sidebar.display === <span class="string">'always'</span>) &#123;</div><div class="line">      NexT.utils.displaySidebar();</div><div class="line">    &#125;</div><div class="line">    integrator.next();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每个方法都调用了integrator.next()方法,而方法顺序是logo-&gt;menu-&gt;postlist-&gt;sidebar. 正好是动画的执行顺序. 作者的意图就不言而喻了, 是控制各部分动画依次进行.我不禁有个疑问,既然velocityjs是支持动画队列的,那干嘛还这么写….. 怀着疑问,突然眼前一亮.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">NexT.motion.integrator = &#123;</div><div class="line">  <span class="attr">queue</span>: [],</div><div class="line">  <span class="attr">cursor</span>: <span class="number">-1</span>,</div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.queue.push(fn);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.cursor++;</div><div class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>.queue[<span class="keyword">this</span>.cursor];</div><div class="line">    $.isFunction(fn) &amp;&amp; fn(NexT.motion.integrator);</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">bootstrap</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.next();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这便是一个简单的队列function依次执行的实现,估计作者是想自己练练手实现一个动画队列吧….</p>
<p>好了,一切都真相大白,拨开云雾见明月.要实现咱们的需求也很简单了. 把作者的动画队列代码删掉就行. 各个部分就能并行执行.</p>
<h2 id="next主题自定义样式"><a href="#next主题自定义样式" class="headerlink" title="next主题自定义样式"></a>next主题自定义样式</h2><p>next的css样式放在了source/css/ 下面，使用了stylus预处理.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">source/css</div><div class="line">    ├── _common         // 各组件部分</div><div class="line">    ├── _custom</div><div class="line">    ├── _mixins         </div><div class="line">    ├── _schemes        // 3套自带样式</div><div class="line">    ├── _variables      // 变量</div><div class="line">    └── main.style      // css入口文件</div></pre></td></tr></table></figure>
<p>_schemes里面的css会覆盖原本的css，优先级高。</p>
<h2 id="技巧分享"><a href="#技巧分享" class="headerlink" title="技巧分享"></a>技巧分享</h2><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你用hexo + github 搭建静态博客]]></title>
      <url>http://http://localhost:4000/2016/08/13/hexo/</url>
      <content type="html"><![CDATA[<p>本来已经有了博客园的博客,但是觉得排版太麻烦,而且受制于平台,不能随性迁移.碰巧看到同事自己搭建的个人网站,心痒痒的.有自己的个人网站是多么炫酷的事情.于是我也去了解了一些建站的相关知识.阿里云主机也去弄了个来玩儿玩儿,不过1月后就没有再续费了.原因嘛很简单,从头到尾自己搞.成本太高了.虽然说能锻炼自己的个人能力,那是肯定的.但是前期投入也确实太大了.本来业余时间也没多少,不想那么瞎折腾.只想找个地儿,简单写写心得体会.本文便是我搭建的全过程.</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近比较流行静态博客网站.即站点并不是动态语言生成,而是静态html页面. hexo就是一个基于markdown的nodejs平台的html静态博客生成器.据说是个台湾人写的.同类型的有jekyll,这玩意儿是基于ruby的,本人不熟.而且gem速度慢的要死,国内被墙了,你懂的.身为前端开发者,果断拥抱nodejs.markdown就不说了,不懂的请自行百度.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>安装依赖</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo brew install nodejs;</div><div class="line">$ sudo brew install git;</div></pre></td></tr></table></figure>
</li>
<li><p>安装hexo</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo npm install -g hexo-cli</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ul>
<li><p>初始化一个工程目录</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">$ cd &lt;folder&gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
</li>
<li><p>目录介绍</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml         // 全局配置</div><div class="line">├── package.json</div><div class="line">├── scaffolds           // 存放草稿</div><div class="line">├── source              // 源码目录</div><div class="line">|   ├── _drafts         // 草稿文件</div><div class="line">|   └── _posts          // 发布的文件</div><div class="line">└── themes              // 主题文件存放地</div></pre></td></tr></table></figure>
</li>
<li><p>创建一篇文章</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&amp; hexo new [layout] &lt;title&gt;</div></pre></td></tr></table></figure>
<p>  如果layout没有传入, 会使用_config.yml文件中的default_layout字段,默认是post<br>  执行命令后,会自动创建一个md文件到/source/_posts/目录下.你可以用你喜欢的编辑器进行编写了.</p>
</li>
</ul>
<ul>
<li><p>本地预览</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="远程部署到github"><a href="#远程部署到github" class="headerlink" title="远程部署到github"></a>远程部署到github</h2><blockquote>
<p>利用github的page功能,可以部署静态网页,拥有无限流量.我们完全可以通过此功能打造我们自己的静态博客网站.不用花一分钱.</p>
</blockquote>
<ol>
<li><p>首先在github上建立一个Repository,仓库名必须是your_user_name.github.io</p>
</li>
<li><p>设置ssh公钥通过验证.</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</div></pre></td></tr></table></figure>
<p> 运行此命令会根据你提供的邮箱创建一对秘钥.</p>
<p> 拷贝.ssh/目录下的id_rsa.pub中的公钥到github</p>
<p> <img src="http://o99eh3ii0.bkt.clouddn.com//16-8-13/74961271.jpg" alt=""></p>
<p> 验证是否联通成功</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure>
<p> 如果成功了,会出现<br> <img src="http://o99eh3ii0.bkt.clouddn.com//16-8-13/40882604.jpg" alt=""></p>
</li>
<li><p>然后配置hexo关联github,修改_config.yml的deploy属性如下:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">deplop:</div><div class="line"></div><div class="line">     type: git</div><div class="line"></div><div class="line">     repo: git@github.com:Alan110/Alan110.github.io.git(你的仓库地址)</div><div class="line"></div><div class="line">     branch: master</div></pre></td></tr></table></figure>
<p> 安装hexo-deploy-git插件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
</li>
<li><p>写好博客后,build下,然后发布. 生成的html静态文件就会发布到github上</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo generate (缩写g) </div><div class="line"></div><div class="line">$ hexo deploy (缩写d)</div></pre></td></tr></table></figure>
</li>
<li><p>访问你的博客</p>
<p>github page页面的访问路径是your_username.github.io</p>
</li>
</ol>
<h2 id="github-io关联域名"><a href="#github-io关联域名" class="headerlink" title="github.io关联域名"></a>github.io关联域名</h2><blockquote>
<p>我们可以给page页面关联上自己的域名,这样它看起来就非常像我们的个人网站了.</p>
</blockquote>
<ul>
<li><p>购买域名</p>
<p>  我是在万网购买的,便宜的1年也就45元.</p>
<p>  配置域名解析<br>  <img src="http://o99eh3ii0.bkt.clouddn.com//16-8-14/65138860.jpg" alt=""></p>
</li>
<li><p>github配置CNAME</p>
<p>  在项目根目录下添加CNAME文件,内容写上域名,注意没有http等协议.</p>
<p>  hexo会覆盖式同步整个工程目录到github,所以CNAME文件要放在source目录里面,否则下次同步会被覆盖.</p>
</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>好了,我们已经完成了一个静态博客网站.可以开始发散我们的思维,记录生活,专研技术.to be better for your love !! .</p>
<p>hexo挺强大的,有很多自定义配置,有兴趣的同学和看看我的另一篇文章</p>
</blockquote>
]]></content>
      
        
    </entry>
    
  
  
</search>
